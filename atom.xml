<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>BelinChung&#39;s Blog</title>
  
  <subtitle>a F2er</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://dearb.me/"/>
  <updated>2018-10-23T05:51:13.000Z</updated>
  <id>https://dearb.me/</id>
  
  <author>
    <name>BelinChung</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Standard Git Commit Message</title>
    <link href="https://dearb.me/archive/2018-10-23/Standard-Git-Commit-Message/"/>
    <id>https://dearb.me/archive/2018-10-23/Standard-Git-Commit-Message/</id>
    <published>2018-10-23T05:46:45.000Z</published>
    <updated>2018-10-23T05:51:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>Fork from: <a href="https://github.com/LiteOS/LiteOS/blob/master/doc/LiteOS_Commit_Message.md" target="_blank" rel="external">LiteOS Commit Message</a></p><h2 id="概要说明"><a href="#概要说明" class="headerlink" title="概要说明"></a>概要说明</h2><p>目前，社区有多种 Commit message 的写法规范。LiteOS采用的是Angular规范，这是目前使用最广的写法，比较合理和系统化，并且有配套的工具。</p><h2 id="Commit-message的作用"><a href="#Commit-message的作用" class="headerlink" title="Commit message的作用"></a>Commit message的作用</h2><p>格式化的Commit message有几个好处：</p><ul><li>提供更多的历史信息，方便快速浏览</li><li>可以过滤某些commit（比如文档改动），便于快速查找信息。</li><li>可以直接从commit生成Change log。</li></ul><a id="more"></a><h2 id="LiteOS-Commit-message的格式"><a href="#LiteOS-Commit-message的格式" class="headerlink" title="LiteOS Commit message的格式"></a>LiteOS Commit message的格式</h2><p>每次提交，Commit message 都包括三个部分：Header，Body 和 Footer。</p><pre><code>&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;空一行&lt;body&gt;空一行&lt;footer&gt;比如：fix(stm32f411):fix stm32f411 migration guide file errorfix some error in stm32f411re migration guide file.Close #75</code></pre><h3 id="Header格式"><a href="#Header格式" class="headerlink" title="Header格式"></a>Header格式</h3><p> Header部分只有一行，包括三个字段：type（必需）、scope（可选）和subject（必需）。</p><ul><li><p>type</p><p>  type用于说明 commit 的类别，只允许使用下面7个标识。</p><p>  feat：新功能（feature）</p><p>  fix：修补bug</p><p>  docs：文档（documentation）</p><p>  style： 格式（不影响代码运行的变动）</p><p>  refactor：重构（即不是新增功能，也不是修改bug的代码变动）</p><p>  test：增加测试</p><p>  chore：构建过程或辅助工具的变动</p><p>  如果type为feat和fix，则该 commit 将肯定出现在 Change log 之中。其他情况（docs、chore、style、refactor、test）由你决定，要不要放入 Change log，建议是不要。</p></li><li><p>scope</p><p>  scope用于说明 commit 影响的范围，比如LiteOS kernel的core修改影响全部则填写all，如果只修改stm32f411的则填写stm32f411。</p></li><li><p>subject</p><p>  subject是 commit 目的的简短描述，不超过50个字符。</p><p>  以动词开头，使用第一人称现在时，比如change，而不是changed或changes</p><p>  第一个字母小写, 结尾不加句号（.）</p></li></ul><h3 id="Body格式"><a href="#Body格式" class="headerlink" title="Body格式"></a>Body格式</h3><p>Body 部分是对本次 commit 的详细描述，可以分成多行。下面是一个范例。</p><pre><code>Add porting contest board projects to LiteOSBoard list:Arduino-M0-PROATSAM4S-XPROATSAMD21-XPROEFM32-SLSTK3400AEFM32-SLSTK3401AEFM32-STK3700FRDM-KL26ZFRDM-KW41Z</code></pre><p>有两个注意点。</p><ul><li><p>使用第一人称现在时，比如使用change而不是changed或changes。</p></li><li><p>应该说明代码变动的动机，以及与以前行为的对比。</p></li></ul><h3 id="Footer格式"><a href="#Footer格式" class="headerlink" title="Footer格式"></a>Footer格式</h3><p>Footer 部分只用于两种情况。</p><ul><li>不兼容变动</li></ul><p>如果当前代码与上一个版本不兼容，则 Footer 部分以BREAKING CHANGE开头，后面是对变动的描述、以及变动理由和迁移方法。</p><pre><code>BREAKING CHANGE: isolate scope bindings definition has changed.    To migrate the code follow the example below:    Before:    scope: {          myAttr: &apos;attribute&apos;,    }    After:    scope: {        myAttr: &apos;@&apos;,    }    The removed `inject` wasn&apos;t generaly useful for directives so there should be no code using it.</code></pre><ul><li><p>关闭 Issue</p><p>  如果当前 commit 针对某个issue，那么可以在 Footer 部分关闭这个 issue 。</p><p>  Closes #16, #24, #92</p></li></ul><h2 id="更多参考"><a href="#更多参考" class="headerlink" title="更多参考"></a>更多参考</h2><p>更详细的commit规则请参考原始的规范说明</p><p><a href="https://github.com/mychaser/docgather/blob/master/GitCommitMessageConventions.pdf" target="_blank" rel="external">Angular规范</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Fork from: &lt;a href=&quot;https://github.com/LiteOS/LiteOS/blob/master/doc/LiteOS_Commit_Message.md&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;LiteOS Commit Message&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;概要说明&quot;&gt;&lt;a href=&quot;#概要说明&quot; class=&quot;headerlink&quot; title=&quot;概要说明&quot;&gt;&lt;/a&gt;概要说明&lt;/h2&gt;&lt;p&gt;目前，社区有多种 Commit message 的写法规范。LiteOS采用的是Angular规范，这是目前使用最广的写法，比较合理和系统化，并且有配套的工具。&lt;/p&gt;
&lt;h2 id=&quot;Commit-message的作用&quot;&gt;&lt;a href=&quot;#Commit-message的作用&quot; class=&quot;headerlink&quot; title=&quot;Commit message的作用&quot;&gt;&lt;/a&gt;Commit message的作用&lt;/h2&gt;&lt;p&gt;格式化的Commit message有几个好处：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;提供更多的历史信息，方便快速浏览&lt;/li&gt;
&lt;li&gt;可以过滤某些commit（比如文档改动），便于快速查找信息。&lt;/li&gt;
&lt;li&gt;可以直接从commit生成Change log。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Others" scheme="https://dearb.me/categories/Others/"/>
    
    
  </entry>
  
  <entry>
    <title>通过合理的配置家庭保险来把控未知风险</title>
    <link href="https://dearb.me/archive/2018-03-02/the-insurance-you-should-buy-at-your-age/"/>
    <id>https://dearb.me/archive/2018-03-02/the-insurance-you-should-buy-at-your-age/</id>
    <published>2018-03-02T05:11:47.000Z</published>
    <updated>2020-12-07T03:30:39.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h4><p>中国人忌讳谈生死，不喜欢也不愿意买保险。不过随着中国的国家和保险业的发展，越来越多人开始接受保险，尝试用保险去规避疾病以及意外带来不可预知的意外。  </p><p>可能提前到来的中年危机，加之久坐和高强度脑力的工作导致身体似乎日渐变差，最近内心不再平静，恐慌感和不安感随之而来。  </p><p>这些天我尝试去了解保险这个行业，看不同保险产品的评测，根据自己的实际配置保险。一份合理配置的保险似乎能消除这些不安，使自己的内心回归平静，舒心的生活、放心的工作。<br><a id="more"></a></p><h5 id="需要了解的观点"><a href="#需要了解的观点" class="headerlink" title="需要了解的观点"></a>需要了解的观点</h5><ul><li>配置保险是一个循序渐进，而非一步到位的过程</li><li>购买保险的顺序是：家庭顶梁柱＞大人＞小孩＞老人</li><li>短期的保险没有长期的保险稳定（年龄越大投保越难）</li><li>一些产品适合用20-30年缴费时间来拉高杠杆</li><li>正确的观点：保险公司都是为了挣钱的</li><li>错误的观点：保险公司理赔困难 （所以买保险要看清楚条款）</li><li>错误的观点：买保险没用到，钱白花了</li><li>等待补充…</li></ul><h4 id="我给自己配置的保险方案"><a href="#我给自己配置的保险方案" class="headerlink" title="我给自己配置的保险方案"></a>我给自己配置的保险方案</h4><h5 id="人物画像"><a href="#人物画像" class="headerlink" title="人物画像"></a>人物画像</h5><ul><li>家庭成员：不到30岁小两口，没有宝宝</li><li>经济情况：年收入 *0w，有100多万的房贷</li><li>过往保障：标准五险，只购买了商业医疗险和意外险</li><li>保险预算：准备使用年收入的 5%-10% 进行保险配置</li></ul><h5 id="配置方案"><a href="#配置方案" class="headerlink" title="配置方案"></a>配置方案</h5><ul><li><p><em>医疗险</em><br>商业医疗险是对社保的一种补充，主要是为了偿付社保无法保险的部分。市面上的百万医疗险保额和疾病保障都大同小异，并没有特别大的区别。下图方案中主要是因为早些时候购买了好医保·住院医疗险，所以写上去。它的弊端就是有1万的起付额，产品停售后无法续保，这个对于1年期的产品来说风险是很大的。<br>后来同事推荐了备选产品中的小雨伞钢铁侠乐享一生百万医疗险，除了具备好医保的产品特征外，它的主要亮点还是合同一期5年，增强版5年累计1万起付。这对于短期保险产品的续保来说还是非常有优势的。</p></li><li><p><em>意外险</em><br>意外险主要保障了保险期间被保险人的遭受的意外伤害和身故。基本上每家的保额和保费都差不多的比例，选择小米代理的这款意外险，主要是因为它含有猝死保障，这应该算是根据自己的职业特色选择的保险产品。</p></li><li><p><em>定期寿险</em><br>简单的说，定期寿险就是给自己的寿命量化一个价值。唐僧保应该是所有的定期寿险里面最高性价比的一款产品了，等待期非常短，健康告知宽松尚可。如果你不吸烟、身体健康，可以选择这块产品，不过这并不适合吸烟群体，吸烟群体的保费大概是不吸烟群体的2倍。线下体检后，保额可提升至2000万。</p></li><li><p><em>重疾险</em><br>重疾主要是在罹患重大疾病（或追加轻疾）后，保险公司赔付约定保额的险种。这个险种应该是所有保险里面年保费最贵的。目前我还没有足够的余钱去购买这类保险，所以只能凭借一些评测资料去推荐一些产品。购买这种产品的核心在于：① 追加轻症并看轻症赔付次数和有无豁免责任 ② 看准消费型的重疾险购买</p></li></ul><p>这样的配置方案，大概支出为 <code>7500元/年/人</code> 左右。<br>下图为 2018.03 推荐的产品。中国保险业不断的壮大，也越来越多性价比高的产品发售。可能下图推荐的产品具有一定的时效性，仅供大家参考。</p><p><img src="https://bstatic.lufeng.info/2018-03-02-WX20180302-142055@2x.png" alt="demo"></p><h4 id="香港保险"><a href="#香港保险" class="headerlink" title="香港保险"></a>香港保险</h4><p>很多人比较质疑和排斥内地保险公司的理赔流程，所以有部分人会建议购买香港的保险。香港人均收入高、寿命长，所以核算保险成本可能会较低，销售价格上自然有一定的优势。</p><ul><li>如果年收入较高、有途径或者方便本人去香港的话，推荐购买香港保险</li><li>香港重疾险保费便宜、理赔简单，疾病的定义相对比较宽松</li><li>售后和纠纷处理依照香港法律，时间和金钱成本较高</li><li>建议本人亲自到港签保险单</li></ul><h4 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h4><p>配置表很早之前在一个技术群给了大家看，大家对于保险都持有不同的看法，有些人保持质疑、有些人觉得没有必要买、有些人跃跃欲试。不管持有怎么样的观点，我都希望每个人都能根据自己的实际情况去配置保险来规避风险。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h4&gt;&lt;p&gt;中国人忌讳谈生死，不喜欢也不愿意买保险。不过随着中国的国家和保险业的发展，越来越多人开始接受保险，尝试用保险去规避疾病以及意外带来不可预知的意外。  &lt;/p&gt;
&lt;p&gt;可能提前到来的中年危机，加之久坐和高强度脑力的工作导致身体似乎日渐变差，最近内心不再平静，恐慌感和不安感随之而来。  &lt;/p&gt;
&lt;p&gt;这些天我尝试去了解保险这个行业，看不同保险产品的评测，根据自己的实际配置保险。一份合理配置的保险似乎能消除这些不安，使自己的内心回归平静，舒心的生活、放心的工作。&lt;br&gt;
    
    </summary>
    
      <category term="Others" scheme="https://dearb.me/categories/Others/"/>
    
    
  </entry>
  
  <entry>
    <title>通过 URL Schemes 和 Universal Links 唤起 APP 的流程设计和代码实现</title>
    <link href="https://dearb.me/archive/2017-12-14/redirect-to-installed-app-with-url-schemes-and-universal-links/"/>
    <id>https://dearb.me/archive/2017-12-14/redirect-to-installed-app-with-url-schemes-and-universal-links/</id>
    <published>2017-12-14T05:37:25.000Z</published>
    <updated>2020-12-07T03:30:39.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="需求描述"><a href="#需求描述" class="headerlink" title="需求描述"></a>需求描述</h3><p>此类需求多出现在运营活动中，通过社交分享的 H5 页面中会有用户交互按钮。用户点击按钮后，如果本机安装了 APP，那么需要打开/跳转至该 APP 中，并在 APP 中触发对应的操作，否则进入到 APP 下载页，引导用户下载 APP，从而获取到新用户增量。</p><p><img src="https://bstatic.lufeng.info/2017-12-14-QQ20171214-135910.png" alt="demo"></p><a id="more"></a><h3 id="以前的实现方式"><a href="#以前的实现方式" class="headerlink" title="以前的实现方式"></a>以前的实现方式</h3><p>在 iOS8 和 Android x.x 之前，前端大神们找到了一个很溜的方法来实现 <code>通过 URL Schemes 跳转 APP 后触发回调函数</code></p><blockquote><p>浏览器接收到 URL 请求发现未知协议，会交给系统处理，系统就能调起客户端了。我们还能趁机检查一下用户是否安装客户端：给iframe 设置一个3-5秒的 CSS3 的transition过渡动画，然后监听动画完成事件，如果用户安装了客户端，那么系统会调起，并将浏览器转入后台运行，进入后台的浏览器一般不会再执行 CSS 动画，这样，我们就能通过判断 CSS 动画执行的时长是否超过预设来判断用户是否安装某个客户端了。</p></blockquote><p>不过这种通过新建一个 iframe 触发 URL Schemes 的方法已经在新版 iOS 和 Android 系统中失效，只是回看下大神们奇异的脑回路。</p><h3 id="现在的实现思路"><a href="#现在的实现思路" class="headerlink" title="现在的实现思路"></a>现在的实现思路</h3><p>大家在拿到这个需求的时候，肯定觉得很简单，直接在2个按钮中加上 URL Schemes 不就完事了吗 <code>URL://action?query=x</code> ？其实我们还遗漏了产品的另一个需求：如果用户没有安装 APP 需要跳转到下载页面，指引用户进行下载。</p><p>但是因为我们已经无法通过 URL Schemes 判断用户是否已经安装了，自然我们也不知道何时需要将用户带到我们的下载页中。</p><h5 id="1-引入中转宣传页"><a href="#1-引入中转宣传页" class="headerlink" title="1. 引入中转宣传页"></a>1. 引入中转宣传页</h5><p>我们不妨改变一下思路，为什么要先触发 URL Schemes 再跳转，而不是先去一个用户可以下载 APP 的页面，再在这个页面触发一次  URL Schemes ，顺带还可以在这个页面做一波品牌宣传。说做就做，我们先来设计下这个作为中转的宣传页：</p><p><img src="https://bstatic.lufeng.info/2017-12-14-QQ20171214-133015@2x.png-w350" alt="demo"></p><p>这个宣传页主要由三部分组成：上部宣传海报、中部下载按钮、下部提示文案+再次触发指引。完美~</p><h5 id="2-通过-URL-Schemes-唤起-APP"><a href="#2-通过-URL-Schemes-唤起-APP" class="headerlink" title="2. 通过 URL Schemes 唤起 APP"></a>2. 通过 URL Schemes 唤起 APP</h5><p>中转宣传页除了达到宣传的作用外，还作为一个全局的跳转处理页面存在，其他活动页不需要额外的处理跳转逻辑，只需要把操作类型和参数组装成一个标准 URL 供用户点击即可。</p><p>不要小看这个页面的逻辑，并非简单的触发一个 URL Schemes ，还要处理微信内置 webview 被阻止的用户提示以及后面的  Universal Links 。所以由一个页面统一的去处理这些逻辑，显然是非常必要的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 通过 URL 中的 query 参数，组装一个 Url Scheme 出来</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUrlScheme</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> scheme = <span class="string">'app://'</span></div><div class="line">  <span class="keyword">var</span> query = parseUrlQuery()</div><div class="line">  <span class="keyword">if</span> (query.hasOwnProperty(<span class="string">'action'</span>)) &#123;</div><div class="line">    scheme += query[<span class="string">'action'</span>]</div><div class="line">    scheme += location.search</div><div class="line">    <span class="keyword">return</span> scheme  </div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">return</span> <span class="literal">null</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> scheme = getUrlScheme()</div><div class="line">  <span class="comment">// 发起一个 Url Scheme 尝试跳转 APP</span></div><div class="line">  scheme &amp;&amp; <span class="built_in">window</span>.open(scheme, <span class="string">'_parent'</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h5 id="3-通过-Universal-Links-唤起-iOS-APP"><a href="#3-通过-Universal-Links-唤起-iOS-APP" class="headerlink" title="3. 通过 Universal Links 唤起 iOS APP"></a>3. 通过 Universal Links 唤起 iOS APP</h5><p>理想很丰满，现实很骨感，提测的包又被打回了。URL Schemes 的方式主要有下面几个缺点：</p><ul><li>iOS 跳转 APP 之前有一个弹窗，需要用户二次确认</li><li>iOS 未安装 APP 的用户会得到一个：无法识别的链接的 alert 提示框</li><li>在第三方 APP （比如微信）这种协议被阻断掉了，完全没反应</li></ul><p>查查资料，iOS9 之后有一个叫 Universal Links 的东西，它的主要原理是：APP 设置好白名单域名，用户在安装好这个 APP 后，系统会根据这个域名从根目录下面的 apple-app-site-association 配置文件中获取到相关的配置信息保存在系统中。系统监听页面访问请求，如果用户从 A 页面点击链接尝试跳转到 B 页面，而 B 页面 URL 属于 Universal Links，那么这个请求将会被系统阻止并跳转到对应的 APP 内。（B 页面将不会被打开，所以配置里面的 PATH 很重要，不然用户可能永远没有机会看到你的 B 页面，除非手工输入 URL 访问）</p><p>它的优点主要是：</p><ul><li>已安装 APP 的用户在从活动页点击按钮尝试跳转到宣传页的时候，会被系统拦截，直接跳转到 APP（就是点击“我要领取”，直接进入 APP，不会再去到宣传页了）</li><li>直接访问宣传页，头部会有一个 APP 介绍 banner，可以手工触发跳转</li><li>重点！重点！由于这个是系统的行为，在第三方 APP （比如微信）无法拦截这种协议的跳转</li></ul><p>至于如何配置  Universal Links ，我这里就不再累赘，网上应该大把的资料，推荐一篇文章给大家吧：<a href="http://www.jianshu.com/p/734c3eff8feb" target="_blank" rel="external">《iOS 9 通用链接（Universal Links）》</a></p><p>那我们就再完善下代码吧~</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> scheme = getUrlScheme()</div><div class="line">  <span class="keyword">if</span> (scheme) &#123;</div><div class="line">    <span class="comment">// 如果是微信内部或者 iOS9 以上的话，就不发送 URL Shceme 请求了，直接通过 Universal Links 跳转 APP</span></div><div class="line">    <span class="keyword">if</span> (ua.isWeChat() || (ua.isiOS() &amp;&amp; ua.getiOSVersion()[<span class="number">0</span>] &gt; <span class="number">8</span>)) &#123;</div><div class="line">      <span class="built_in">console</span>.log(<span class="string">'try to launch app with universal links'</span>)</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="built_in">console</span>.log(<span class="string">'launch app with url scheme'</span>)      </div><div class="line">      <span class="built_in">window</span>.open(scheme, <span class="string">'_parent'</span>);      </div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>好了，终于可以放心的推广活动了！O(∩_∩)O~~</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;需求描述&quot;&gt;&lt;a href=&quot;#需求描述&quot; class=&quot;headerlink&quot; title=&quot;需求描述&quot;&gt;&lt;/a&gt;需求描述&lt;/h3&gt;&lt;p&gt;此类需求多出现在运营活动中，通过社交分享的 H5 页面中会有用户交互按钮。用户点击按钮后，如果本机安装了 APP，那么需要打开/跳转至该 APP 中，并在 APP 中触发对应的操作，否则进入到 APP 下载页，引导用户下载 APP，从而获取到新用户增量。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://bstatic.lufeng.info/2017-12-14-QQ20171214-135910.png&quot; alt=&quot;demo&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Others" scheme="https://dearb.me/categories/Others/"/>
    
    
  </entry>
  
  <entry>
    <title>使用 macOS 的 screencapture 程序为 Electron 应用实现原生截图功能</title>
    <link href="https://dearb.me/archive/2017-11-01/electron-screenshot-base-on-macos-screencapture/"/>
    <id>https://dearb.me/archive/2017-11-01/electron-screenshot-base-on-macos-screencapture/</id>
    <published>2017-11-01T07:24:50.000Z</published>
    <updated>2020-12-07T03:30:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>基于 Electron 开发即时通讯 APP，截图功能后期势必成为一个刚需的功能。Webkit 中的 <code>desktopCapture</code> API 只能截取当前窗口的画面，用户的实际需求还是需要全屏选取范围截取。如果需要一个跨平台的插件实现，可能需要使用原生开发出一个截图应用，然后再暴露给 Electron 调用。   </p><p>如果你只是需要实现 macOS 平台的截图功能，那么内置的 <code>screencapture</code> 程序也许已经满足了我们的使用需求。我们先在 terminal 中查看下 <code>screencapture</code> 程序有哪些 API 提供</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">screencapture -h</div><div class="line">screencapture: illegal option -- h</div><div class="line">usage: screencapture [-icMPmwsWxSCUtoa] [files]</div><div class="line">  -c         force screen capture to go to the clipboard</div><div class="line">  -b         capture Touch Bar - non-interactive modes only</div><div class="line">  -C         capture the cursor as well as the screen. only <span class="keyword">in</span> non-interactive modes</div><div class="line">  ...</div><div class="line">  ...</div></pre></td></tr></table></figure><a id="more"></a><p><code>screencapture</code> 程序提供了命令行式的调用方式，我们只需要在 Electron 的主进程中使用 NodeJS 运行我们需要执行的命令就可以了。<br>二次封装有利于我们后期的维护和替换，很高兴轮子已经有人帮我们造好了：<a href="https://github.com/rogerbf/macos-screencapture" target="_blank" rel="external">rogerbf/macos-screencapture</a></p><p>我们的需求希望用户截图后，截取的图片需要保存在系统的剪切板和指定的目录中。但是发现使用 <code>-c</code> 后，不能同时保存至指定的目录中，那只能曲线救国了，先保存在指定的目录中，然后使用 <code>clipboard</code> API 写入到剪切板中。</p><p>假设我们通过某个入口执行起截图功能：<br><code>主进程：main.js</code><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">openScreenCapturer</span>(<span class="params"></span>) </span>&#123;</div><div class="line">   <span class="comment">//指定保存的目录是在 /用户目录/图片 中</span></div><div class="line">   <span class="keyword">const</span> basePath = path.join(<span class="built_in">require</span>(<span class="string">'home-path'</span>)(), <span class="string">'./Pictures/cn.lunkr.screenCapture/'</span>)</div><div class="line">   </div><div class="line">   <span class="comment">//使用当前时间作为图片名称</span></div><div class="line">   <span class="keyword">const</span> imageName = <span class="string">`lunkr-<span class="subst">$&#123;utils.parseTime(<span class="keyword">new</span> <span class="built_in">Date</span>(), <span class="string">'&#123;y&#125;&#123;m&#125;&#123;d&#125;&#123;h&#125;&#123;i&#125;&#123;s&#125;'</span>)&#125;</span>.png`</span></div><div class="line">   <span class="keyword">const</span> imagePath = basePath + imageName</div><div class="line">   <span class="keyword">const</span> exists = pathExists.sync(basePath)</div><div class="line">   </div><div class="line">   <span class="comment">//需要预先判断这个目录是否存在，不存在的话执行一次 mkdir</span></div><div class="line">   <span class="keyword">if</span>(exists) &#123;</div><div class="line">      doScreencapture(imagePath)</div><div class="line">   &#125; <span class="keyword">else</span> &#123;</div><div class="line">       <span class="keyword">try</span> &#123;</div><div class="line">           <span class="keyword">if</span>(mkdir.sync(basePath)) doScreencapture(imagePath)</div><div class="line">       &#125; <span class="keyword">catch</span> (e) &#123;</div><div class="line">           <span class="built_in">console</span>.log(e)</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>调起系统的截图程序，然后通知渲染进程进行二次确认<br><code>主程序：main.js</code><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">doScreencapture</span>(<span class="params">path</span>) </span>&#123;</div><div class="line">    <span class="keyword">const</span> pArr = path.split(<span class="string">'/'</span>)</div><div class="line"></div><div class="line">    <span class="comment">//调用 screencapture，-s 强制鼠标选择模式</span></div><div class="line">    screencapture(&#123;</div><div class="line">        path: path,</div><div class="line">        options: [<span class="string">'-s'</span>]</div><div class="line">    &#125;).then(<span class="function"><span class="params">path</span> =&gt;</span> &#123;</div><div class="line">        <span class="comment">//截图成功的回调，使用 nativeImage API 从 PATH 中读取出保存的图片</span></div><div class="line">        <span class="keyword">const</span> image =  nativeImage.createFromPath(path)</div><div class="line">        </div><div class="line">        <span class="comment">//写入到剪切板</span></div><div class="line">        clipboard.writeImage(image)</div><div class="line">        </div><div class="line">        <span class="comment">//将图片读取为 dataURL 格式</span></div><div class="line">        <span class="keyword">const</span> dataURL = image.toDataURL()</div><div class="line">        </div><div class="line">        <span class="comment">//使用内置的事件系统，将 dataURL 格式的图片通知给渲染程序</span></div><div class="line">        mainWindow.webContents.send(<span class="string">'screen-captured'</span>, &#123;</div><div class="line">            dataURL,</div><div class="line">            fileName: pArr[pArr.length - <span class="number">1</span>]</div><div class="line">        &#125;)</div><div class="line">    &#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">`error: <span class="subst">$&#123;err&#125;</span>`</span>))</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>渲染程序监听到主程序的事件后，进行交互层面的用户二次确定<br><code>渲染程序：index.js</code><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> ipcRenderer = <span class="built_in">window</span>.Electron.ipc</div><div class="line"></div><div class="line"><span class="comment">//使用 ipc 监听主程序发送的事件</span></div><div class="line">ipcRenderer.on(<span class="string">'screen-captured'</span>, (event, message) =&gt; &#123;</div><div class="line">    <span class="comment">//将 dataUrl 的图片转换成 file 对象</span></div><div class="line">    <span class="keyword">const</span> file = dataURLtoFile(message.dataURL, message.fileName)</div><div class="line">    </div><div class="line">    <span class="comment">//弹出确认预览框</span></div><div class="line">    openScreenCaptureModal(&#123;</div><div class="line">      file,</div><div class="line">      name: message.fileName,</div><div class="line">      dataURL: message.dataURL</div><div class="line">    &#125;)</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">//额外赠送~</span></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">dataURLtoFile</span>(<span class="params">dataurl, filename</span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> arr = dataurl.split(<span class="string">','</span>)</div><div class="line">  <span class="keyword">const</span> mime = arr[<span class="number">0</span>].match(<span class="regexp">/:(.*?);/</span>)[<span class="number">1</span>]</div><div class="line">  <span class="keyword">const</span> bstr = atob(arr[<span class="number">1</span>])</div><div class="line">  <span class="keyword">let</span> n = bstr.length</div><div class="line">  <span class="keyword">const</span> u8arr = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(n)</div><div class="line">  <span class="keyword">while</span>(n--)&#123;</div><div class="line">    u8arr[n] = bstr.charCodeAt(n)</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> File([u8arr], filename, &#123;<span class="attr">type</span>:mime&#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>大概的实现思路和核心的代码就这些啦，希望对一些朋友有所帮助<br>效果如下图所示：</p><p><img src="https://bstatic.lufeng.info/mac_screencapture.gif" alt="preview"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;基于 Electron 开发即时通讯 APP，截图功能后期势必成为一个刚需的功能。Webkit 中的 &lt;code&gt;desktopCapture&lt;/code&gt; API 只能截取当前窗口的画面，用户的实际需求还是需要全屏选取范围截取。如果需要一个跨平台的插件实现，可能需要使用原生开发出一个截图应用，然后再暴露给 Electron 调用。   &lt;/p&gt;
&lt;p&gt;如果你只是需要实现 macOS 平台的截图功能，那么内置的 &lt;code&gt;screencapture&lt;/code&gt; 程序也许已经满足了我们的使用需求。我们先在 terminal 中查看下 &lt;code&gt;screencapture&lt;/code&gt; 程序有哪些 API 提供&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;screencapture -h&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;screencapture: illegal option -- h&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;usage: screencapture [-icMPmwsWxSCUtoa] [files]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  -c         force screen capture to go to the clipboard&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  -b         capture Touch Bar - non-interactive modes only&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  -C         capture the cursor as well as the screen. only &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; non-interactive modes&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  ...&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  ...&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Electron" scheme="https://dearb.me/categories/Electron/"/>
    
    
  </entry>
  
  <entry>
    <title>通过使用 HTTP/2 提高你的网站的访问速度</title>
    <link href="https://dearb.me/archive/2016-10-14/enable-http2-for-your-website/"/>
    <id>https://dearb.me/archive/2016-10-14/enable-http2-for-your-website/</id>
    <published>2016-10-14T03:42:03.000Z</published>
    <updated>2020-12-07T03:30:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>随着 Web 的发展，HTTP/1.x 已经很难满足现在的需求，Google 因此开发了 SPDY 作为尝试，HTTP/2 在此基础上应运而生。HTTP/2 在2015年5月被批准，目前已经在很多 Web 浏览器和服务器中得到实现。</p><p>HTTP/2 和 TLS 组合可以提升你的站点性能，并且让用户觉得你的网站很安全。</p><h3 id="服务器软件版本支持"><a href="#服务器软件版本支持" class="headerlink" title="服务器软件版本支持"></a>服务器软件版本支持</h3><p>请确保你服务器的软件版本号支持开启 HTTP/2，否则坑很大，坑死人。</p><ul><li>Nginx ≥ v1.9.5</li><li>openSSL ≥ v1.0.2</li></ul><a id="more"></a><h3 id="编译安装-升级-openSSL"><a href="#编译安装-升级-openSSL" class="headerlink" title="编译安装/升级 openSSL"></a>编译安装/升级 openSSL</h3><p>目前我的机器是 Ubuntu，其他 Linux 发行版应该也大同小异</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ wget https://www.openssl.org/<span class="built_in">source</span>/openssl-1.0.2j.tar.gz &amp;&amp; tar -xzvf openssl-1.0.2j.tar.gz &amp;&amp; <span class="built_in">cd</span> openssl-1.0.2j</div><div class="line">$ sudo ./config</div><div class="line">$ sudo make install</div><div class="line">$ sudo ln -sf /usr/<span class="built_in">local</span>/ssl/bin/openssl `<span class="built_in">which</span> openssl`</div><div class="line">$ openssl version -v</div></pre></td></tr></table></figure><p>可以看到 openSSL 的版本已经升级至 1.0.2j</p><h3 id="编译安装-升级-Nginx"><a href="#编译安装-升级-Nginx" class="headerlink" title="编译安装/升级 Nginx"></a>编译安装/升级 Nginx</h3><p>如果你的机器现在安装的 Nginx ＜ 1.9.5 或者 built with OpenSSL 版本 ＜ 1.0.2，那么需要重新编译一个高版本的 Nginx</p><p>具体升级过程可根据自己的实际情况，唯一要注意的是编译参数可以加上刚刚的 openSSL 目录，以防万一</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ ./configure  \</div><div class="line">$ --with-openssl=path/to/openssl-1.0.2j</div></pre></td></tr></table></figure><p>升级好后，通过 <code>nginx -V</code> 查看版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">nginx version: nginx/1.10.1 &lt;-- 注意这里</div><div class="line">built by gcc 4.8.2 (Ubuntu 4.8.2-19ubuntu1)</div><div class="line">built with OpenSSL 1.0.2j  26 Sep 2016  &lt;-- 注意这里</div><div class="line">TLS SNI support enabled</div><div class="line">configure arguments: --user=www --group=www --prefix=/usr/<span class="built_in">local</span>/nginx --with-openssl=/root/openssl-1.0.2j --with-http_stub_status_module --with-http_ssl_module --with-http_v2_module --with-http_gzip_static_module --with-ipv6 --with-http_sub_module</div></pre></td></tr></table></figure><h3 id="通过配置-Nginx-文件开启-HTTP-2"><a href="#通过配置-Nginx-文件开启-HTTP-2" class="headerlink" title="通过配置 Nginx 文件开启 HTTP/2"></a>通过配置 Nginx 文件开启 HTTP/2</h3><p>目前 Firefox 和 Chrome 明确地表示，他们只实现基于 TLS 的 HTTP/2，所以请先确保你的网站已经支持了 HTTPS</p><p>相关博文：<a href="https://dearb.me/archive/2015-03-23/use-ssl-certificates-to-protect-your-website-visitors-data/">《使用 SSL 证书保护网站的访问》</a></p><p>然后开启的步骤非常的简单，只需在配置文件中加上 http2 关键字即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">server &#123;  </div><div class="line">  listen       443 ssl http2; </div><div class="line">  server_name  dearb.me;</div><div class="line"></div><div class="line">  <span class="comment">#SSL配置</span></div><div class="line">  ssl                   on;</div><div class="line">  ssl_certificate       /etc/nginx/conf.d/certificate.crt;</div><div class="line">  ssl_certificate_key   /etc/nginx/conf.d/certificate.key;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="通过-Chrome-Network-标签验证结果"><a href="#通过-Chrome-Network-标签验证结果" class="headerlink" title="通过 Chrome Network 标签验证结果"></a>通过 Chrome Network 标签验证结果</h3><p><img src="https://bstatic.lufeng.info/2016-10-14-573DD65E-3A94-49C3-872C-4EEF3C240189.png" alt="573DD65E-3A94-49C3-872C-4EEF3C240189"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;随着 Web 的发展，HTTP/1.x 已经很难满足现在的需求，Google 因此开发了 SPDY 作为尝试，HTTP/2 在此基础上应运而生。HTTP/2 在2015年5月被批准，目前已经在很多 Web 浏览器和服务器中得到实现。&lt;/p&gt;
&lt;p&gt;HTTP/2 和 TLS 组合可以提升你的站点性能，并且让用户觉得你的网站很安全。&lt;/p&gt;
&lt;h3 id=&quot;服务器软件版本支持&quot;&gt;&lt;a href=&quot;#服务器软件版本支持&quot; class=&quot;headerlink&quot; title=&quot;服务器软件版本支持&quot;&gt;&lt;/a&gt;服务器软件版本支持&lt;/h3&gt;&lt;p&gt;请确保你服务器的软件版本号支持开启 HTTP/2，否则坑很大，坑死人。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Nginx ≥ v1.9.5&lt;/li&gt;
&lt;li&gt;openSSL ≥ v1.0.2&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="SSL" scheme="https://dearb.me/categories/SSL/"/>
    
    
  </entry>
  
  <entry>
    <title>通过重写一个 Demo 小项目尝鲜微信小程序以及自己的一些看法</title>
    <link href="https://dearb.me/archive/2016-10-13/talk-about-wechat-app/"/>
    <id>https://dearb.me/archive/2016-10-13/talk-about-wechat-app/</id>
    <published>2016-10-13T06:07:14.000Z</published>
    <updated>2016-10-13T06:12:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>一直对 Hybrid App 有比较浓厚的兴趣。包括几年前玩的 Phonegap/Cordova 和最近玩的 react-native，Webview 模式下的 Hybrid 在 Android 设备上显然有一些性能上的缺陷。 RN 看似不错，很多大厂也陆续把 APP 的部分模块或整个 APP 通过 RN 重写，但前途如何，不得而知，毕竟 “前会玩”。</p><p>V2 上很多关于 [ Hybrid App 能否取代原生APP ] 的主题下讨论的热火朝天，不亚于 [ PHP 是否是世界上最好的语言 ] 的讨论。为什么是取代而不是共存呢？</p><a id="more"></a><ul><li><p>米家 APP 里的小米商城</p></li><li><p>手机QQ 里的 QQ 空间</p></li><li><p>微信里的微信小程序</p></li></ul><p>显然有些 APP 整体需要原生的稳定性和高性能，而里面的一些业务模块需要快捷开发、可维护、高可控性，如何解决这样的冲突，明显需要一个可行的 Hybrid 解决方案。甚至 APP 里某些模块 Hybrid 化后，团队有其他看法，将整个 APP Hybrid 重构，比如米家 iOS 本次更新已经整体用 RN 重写了。</p><h2 id="微信小程序"><a href="#微信小程序" class="headerlink" title="微信小程序"></a>微信小程序</h2><p>你可以在这里 Checkout 源码：<a href="https://github.com/BelinChung/wxapp-hiapp" target="_blank" rel="external">BelinChung/wxapp-hiapp</a></p><p>公司最近有打算做项目的微信整合方案，刚好小程序内测，花了几天写了这个小 Demo ，当做是可行性调研。总得来说，写过 RN 和 VueJS 的同学会很快的入手，很有 Virtual DOM 和 VueJS API 的味道，但是目前看起来各方面都还在完善当中，有很多坑陆陆续续微信开发团队在填补中。因为没能真机调试的原因，其实现在在开发者工具中展现不能100%在真机中跑起来，只能静观其变了。</p><p>从现在来看微信小程序并不是 HTML5 应用，而是与 react-native 类似通过 JavaScript 作为描述语言堆砌内置的原生组件，按道理产出的应用应该是真正意义上的原生应用。可是目前看来，前期的版本可能还是跑在 Webview 中，希望后期迭代或者完全发布之后，能是上述所说的吧。</p><h4 id="Preview"><a href="#Preview" class="headerlink" title="Preview"></a>Preview</h4><p><img src="https://raw.githubusercontent.com/BelinChung/wxapp-hiapp/master/demo/demo_v0.2.gif" alt="Preview"></p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>如果你希望获取到 HiApp 的 react-native 版本，Checkout: <a href="https://github.com/BelinChung/react-native-hiapp" target="_blank" rel="external">BelinChung/react-native-hiapp</a></p><p>如果你希望获取到 HiApp 的 Phonegap/Cordova 版本，Checkout: <a href="https://github.com/BelinChung/HiApp" target="_blank" rel="external">BelinChung/HiApp</a></p><p>最后，希望 HiApp 对喜欢 Hybrid App 的同学有所帮助。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一直对 Hybrid App 有比较浓厚的兴趣。包括几年前玩的 Phonegap/Cordova 和最近玩的 react-native，Webview 模式下的 Hybrid 在 Android 设备上显然有一些性能上的缺陷。 RN 看似不错，很多大厂也陆续把 APP 的部分模块或整个 APP 通过 RN 重写，但前途如何，不得而知，毕竟 “前会玩”。&lt;/p&gt;
&lt;p&gt;V2 上很多关于 [ Hybrid App 能否取代原生APP ] 的主题下讨论的热火朝天，不亚于 [ PHP 是否是世界上最好的语言 ] 的讨论。为什么是取代而不是共存呢？&lt;/p&gt;
    
    </summary>
    
      <category term="WeChat App" scheme="https://dearb.me/categories/WeChat-App/"/>
    
    
  </entry>
  
  <entry>
    <title>升级 react-native 到 v0.29.x 后 Android 平台部分插件无法使用的问题</title>
    <link href="https://dearb.me/archive/2016-08-09/upgrade-react-native-to-v0-29/"/>
    <id>https://dearb.me/archive/2016-08-09/upgrade-react-native-to-v0-29/</id>
    <published>2016-08-09T06:46:47.000Z</published>
    <updated>2020-12-07T03:30:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>首先我们来看一下官方的 Changelog 这个版本有哪些 breaking changes。其中大部分变更暂时我还没有使用到，所以就忽略。但是 Android 有个变更貌似改变挺大了，也直接导致了大部分的第三方插件直接无法使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Change the application template (49f20f4) - @foghina</div><div class="line">* Plugins which pass activity reference in the constructor need to be updated to extend ReactContextBaseJavaModule use getCurrentActivity to get the activity reference. This change is backward compatible.</div><div class="line">* Apps need to be migrated to use the latest template</div></pre></td></tr></table></figure><p>大概的意思是：这个版本我们变更了 APP 的模板，如果你的插件选择在构造函数中传递当前的 activity，那么在这个版本中需要升级到通过继承 ReactContextBaseJavaModule 来获取当前的 activity，这个改变是可以向下兼容的。<br><a id="more"></a></p><h4 id="部分第三方插件无法使用了"><a href="#部分第三方插件无法使用了" class="headerlink" title="部分第三方插件无法使用了"></a>部分第三方插件无法使用了</h4><p>其中我正在使用的 <a href="https://github.com/jaysoo/react-native-extra-dimensions-android" target="_blank" rel="external">react-native-extra-dimensions-android</a> 也是遇到了相同的问题，而且好像作者好像弃坑了，所以只能自己尝试按照上面官方的建议进行改造升级</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">error: incompatible types &lt;anonymous ReactNativeHost&gt; cannot be converted to Ativity </div><div class="line">new ExtraDimensionsPackage(this) &lt;--</div></pre></td></tr></table></figure><h4 id="尝试改造第三方插件"><a href="#尝试改造第三方插件" class="headerlink" title="尝试改造第三方插件"></a>尝试改造第三方插件</h4><p>自己动手，丰衣足食。下面的步骤是针对 react-native-extra-dimensions-android 进行改造，但是整个改造的过程是适合其他遇到相同问题的插件，万变不离其宗。</p><h5 id="在-MainApplication-java-注册插件"><a href="#在-MainApplication-java-注册插件" class="headerlink" title="在 MainApplication.java 注册插件"></a>在 MainApplication.java 注册插件</h5><p>从 v0.29.0 开始，Android 项目新增了 <code>MainApplication.java</code> 模板，大部分以前在 <code>MainActivity.java</code> 的逻辑迁移到了这里</p><p>Register module (in MainApplication.java)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> ca.jaysoo.extradimensions.ExtraDimensionsPackage;  <span class="comment">// &lt;--- import</span></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainApplication</span> <span class="keyword">extends</span> <span class="title">Application</span> <span class="keyword">implements</span> <span class="title">ReactApplication</span> </span>&#123;</div><div class="line">  ......</div><div class="line">  <span class="function"><span class="keyword">protected</span> List&lt;ReactPackage&gt; <span class="title">getPackages</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> Arrays.&lt;ReactPackage&gt;asList(</div><div class="line">      <span class="keyword">new</span> MainReactPackage(),</div><div class="line">      <span class="keyword">new</span> ExtraDimensionsPackage()  <span class="comment">// &lt;--- add here</span></div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">  ......</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>上面只是代码位置迁移，只是 new 的时候少了 <code>this</code> 这个参数，因为这时候 <code>this</code> 已经不再是 <code>current activity</code> 了，这也是导致整个问题的重要原因！</p><h5 id="尝试通过其他方法找回-Current-Activity"><a href="#尝试通过其他方法找回-Current-Activity" class="headerlink" title="尝试通过其他方法找回 Current Activity"></a>尝试通过其他方法找回 Current Activity</h5><p>因为 Current Activity 已经不再通过构造函数传递进来了，我们只能通过其他的方式尝试找回 <code>Current Activity</code></p><p><code>ExtraDimensionsPackage</code> 类中已经没有 activity 相关的逻辑了，那我们清理一下无用的代码。</p><p><img src="https://bstatic.lufeng.info/2016-08-09-QQ20160809-0@2x.png" alt="image"></p><p>接下来就是重点了，修改 <code>ExtraDimensionsModule</code> 类中相关的代码。按照官方的建议通过继承 <code>ReactContextBaseJavaModule</code> 来获取 <code>getCurrentActivity()</code> 这个方法，看起来好容易就可以完成啦！！</p><p><img src="https://bstatic.lufeng.info/2016-08-09-14707278487220.jpg" alt="image"></p><p>继承、重写生命周期的部分方法…上面其实都是例行书写，对于改造是没有任何卵用的。<br>接下来按道理我们只用全局替换 <code>mCurrentActivity</code> 成 <code>getCurrentActivity()</code> 就可以大功告成了。</p><p>编译、运行…哎呀，我艹，没有 <code>getCurrentActivity()</code> 这个方法？不是官方推荐的吗？方法呢？被狗吃了吗？<br>后来我尝试去翻源码，60%确定这个方法不存在或者没有暴露出来，但是毕竟我只是个小前端，可能用错了吧。</p><p>（16.08.16更新）在 RN0.31.0 中 <code>getCurrentActivity()</code> 被 public 出来了，基本上我上面说的是对的，这个方法被狗吃了。具体的 commit 可以参阅：<a href="https://github.com/facebook/react-native/commit/760656461197605ee26769ed73989f78e4753038" target="_blank" rel="external">7606564</a></p><p>先不管了，那就查查还有什么方法可以获取到 <code>Current Activity</code>，Google 告诉我 <code>WindowManager</code> 也是可以拿到当前活跃的 activity 的！</p><p><img src="https://bstatic.lufeng.info/2016-08-09-14707282814498.jpg" alt="image"></p><p> 大功告成！！</p><ul><li>相关 Commit Diff: <a href="https://github.com/BelinChung/react-native-extra-dimensions-android/commit/6f1a73d31787b7e13cf4f36eee2bb9c7332f69a1" target="_blank" rel="external">BelinChung/react-native-extra-dimensions-android#6f1a73d3</a></li><li>相关项目 <a href="https://github.com/BelinChung/react-native-hiapp" target="_blank" rel="external">BelinChung/react-native-hiapp</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;首先我们来看一下官方的 Changelog 这个版本有哪些 breaking changes。其中大部分变更暂时我还没有使用到，所以就忽略。但是 Android 有个变更貌似改变挺大了，也直接导致了大部分的第三方插件直接无法使用&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;Change the application template (49f20f4) - @foghina&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;* Plugins which pass activity reference in the constructor need to be updated to extend ReactContextBaseJavaModule use getCurrentActivity to get the activity reference. This change is backward compatible.&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;* Apps need to be migrated to use the latest template&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;大概的意思是：这个版本我们变更了 APP 的模板，如果你的插件选择在构造函数中传递当前的 activity，那么在这个版本中需要升级到通过继承 ReactContextBaseJavaModule 来获取当前的 activity，这个改变是可以向下兼容的。&lt;br&gt;
    
    </summary>
    
      <category term="react-native" scheme="https://dearb.me/categories/react-native/"/>
    
    
  </entry>
  
  <entry>
    <title>Electron APP 支持应用内下载文件及显示下载进度</title>
    <link href="https://dearb.me/archive/2016-05-19/Electron-APP-support-download-progress/"/>
    <id>https://dearb.me/archive/2016-05-19/Electron-APP-support-download-progress/</id>
    <published>2016-05-19T03:27:21.000Z</published>
    <updated>2016-05-19T04:46:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近把公司一个 Web APP 项目用 Electron 封装了一个 Mac 客户端，主要是弥补了 Web 浏览器的一些先天不足：</p><ul><li>支持原生的通知</li><li>支持原生的 icon 未读提醒</li><li>支持原生的系统托盘</li><li>增强网络状态变更的感知</li></ul><p>其中以前下载方式是通过打开系统浏览器进行文件下载的。因为文件需要鉴权，还得携带一些敏感的 cookie、token 过去，感觉不安全，所以希望文件下载能在 APP 内完成<br><a id="more"></a><br>通过 Electron 中 <code>will-download</code> 事件，我们可以很方便的解决这个问题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">mainWindow.webContents.session.on(&apos;will-download&apos;, (e, item) =&gt; &#123;</div><div class="line">//获取文件的总大小</div><div class="line">   const totalBytes = item.getTotalBytes();</div><div class="line"></div><div class="line">//设置文件的保存路径，此时默认弹出的 save dialog 将被覆盖</div><div class="line">   const filePath = path.join(app.getPath(&apos;downloads&apos;), item.getFilename());</div><div class="line">   item.setSavePath(filePath);</div><div class="line"></div><div class="line">//监听下载过程，计算并设置进度条进度</div><div class="line">   item.on(&apos;updated&apos;, () =&gt; &#123;</div><div class="line">       mainWindow.setProgressBar(item.getReceivedBytes() / totalBytes);</div><div class="line">   &#125;);</div><div class="line"></div><div class="line">//监听下载结束事件</div><div class="line">   item.on(&apos;done&apos;, (e, state) =&gt; &#123;</div><div class="line">   //如果窗口还在的话，去掉进度条</div><div class="line">       if (!mainWindow.isDestroyed()) &#123;</div><div class="line">           mainWindow.setProgressBar(-1);</div><div class="line">       &#125;</div><div class="line"></div><div class="line">//下载被取消或中断了</div><div class="line">       if (state === &apos;interrupted&apos;) &#123;</div><div class="line">           electron.dialog.showErrorBox(&apos;下载失败&apos;, `文件 $&#123;item.getFilename()&#125; 因为某些原因被中断下载`);</div><div class="line">       &#125;</div><div class="line"></div><div class="line">//下载完成，让 dock 上的下载目录Q弹一下下</div><div class="line">       if (state === &apos;completed&apos;) &#123;</div><div class="line">           app.dock.downloadFinished(filePath);</div><div class="line">       &#125;</div><div class="line">   &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近把公司一个 Web APP 项目用 Electron 封装了一个 Mac 客户端，主要是弥补了 Web 浏览器的一些先天不足：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;支持原生的通知&lt;/li&gt;
&lt;li&gt;支持原生的 icon 未读提醒&lt;/li&gt;
&lt;li&gt;支持原生的系统托盘&lt;/li&gt;
&lt;li&gt;增强网络状态变更的感知&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其中以前下载方式是通过打开系统浏览器进行文件下载的。因为文件需要鉴权，还得携带一些敏感的 cookie、token 过去，感觉不安全，所以希望文件下载能在 APP 内完成&lt;br&gt;
    
    </summary>
    
      <category term="Electron" scheme="https://dearb.me/categories/Electron/"/>
    
    
  </entry>
  
  <entry>
    <title>这些生产力 OS X APP 帮助我提供工作效率</title>
    <link href="https://dearb.me/archive/2016-02-29/osx-exp-share/"/>
    <id>https://dearb.me/archive/2016-02-29/osx-exp-share/</id>
    <published>2016-02-29T09:03:18.000Z</published>
    <updated>2016-12-16T02:27:05.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h4><p>使用 MacBook Pro 也2年多了，慢慢地积累了一些工作中好用的 APP，帮助自己更高效的工作。正版化也一直在进行着，除了 IDE 用的是教育版订阅之外，其他已经都是正版了（但我不排除 License 授权不支持工作用），力所能及的支持正版吧，毕竟自己也是软件开发从业者。</p><h4 id="APP-合集"><a href="#APP-合集" class="headerlink" title="APP 合集"></a>APP 合集</h4><p>每个 APP 对应一段简单的描述，数量还不多，就暂时不分类了，大概的排一下。<br><a id="more"></a></p><ul><li><strong>Dropbox</strong> - 云存储服务，用来同步代码及本机一些开发配置，需要科学上网才可使用</li><li><strong>iTerm</strong> - Mac OS 终端增强，配合 <code>Oh My Zsh</code> 效果更佳</li><li><strong>Evernote</strong> - 多功能笔记类应用，我比较喜欢它在 Chrome 下的<code>剪藏</code>功能</li><li><strong>GapDebug</strong> - Hybrid APP 调试利器，不过也可以调试普通的 Mobile Web 页面及 APP 内嵌页</li><li><strong>iStat Menus</strong> - 系统菜单栏增强，可以显示实时网速、CPU 内存使用情况、配件温度、电池状态等等…</li><li><strong>GIF Brewery 3</strong> - 屏幕录制及 GIF 转换工具</li><li><strong>Dash</strong> - API 文档浏览器及代码片段管理器，IAP 后启动就不用读秒了</li><li><strong>ReadKit</strong> - RSS 订阅器，写代码写累了就看看圈内新闻吧</li><li><strong>1Password</strong> - 密码管理器，以后你只需要记住一个主密码就行了，其他都随机生成吧</li><li><strong>MWeb</strong> - 优秀的 Markdown 编辑器，这篇文章就是在这个软件里写的哦</li><li><strong>WebStorm</strong> - 前端工程师必备的 IDE，杀牛就要用牛刀</li><li><strong>Sublime Text</strong> - 一款非常优秀的编辑器，有时候杀鸡焉用牛刀</li><li><strong>Chrome</strong> - 可能是世界上最好用的浏览器了</li><li><strong>Microsoft Office 2016</strong> - 工作套件，有时候还是用得到的</li><li><strong>MPlayerX</strong> - 优秀的、支持格式广泛的播放器</li><li><strong>Sequel Pro</strong> - MySQL 数据库管理工具</li><li><strong>Spark</strong> - 邮件客户端，还是不错的</li><li><strong>Caffeine</strong> - 一款可以让你的 Mac 屏幕一直亮到没电的小软件</li><li><strong>Alfred</strong> - Mac 平台上最为传奇的效率作品,誉为神兵利器毫不为过,只能说到这里了</li><li><strong>Postman</strong> - 一款优秀的调试 API 的 Chrome APP</li><li><strong>Cakebrew</strong> - Brew 可视化管理工具</li><li><strong>SourceTree</strong> - Git 可视化管理工具</li><li><strong>BetterZip</strong> - 一款优秀的解压缩软件</li><li><strong>Moom</strong> - 一款优秀的窗口布局智能管理软件，用得好，很是能提高工作效率</li><li><strong>Bartender</strong> - 菜单栏的常住 APP icon 越来越多，是时候收起来一些了</li><li><strong>Mark Man</strong> - 标颜色、拉尺寸什么的，还是前端自己来好了</li><li><strong>Polarr Photo Editor</strong> - 泼辣修图，PS 卸载之后，就只能靠它简单的修图了</li><li><strong>Code Runner</strong> - 可直接跑多种编程语言的代码段，开发必备</li><li><strong>Paste</strong> - 系统粘贴板管理与增强软件，V2.0 之后 Pinboard 的功能我还是很喜欢的</li><li><strong>VSCode</strong> - 一款跨平台的编辑器，微软果然是专业的 IDE 工匠</li><li><strong>Surge for Mac</strong> - 网络调试及开发工具，还有的核心功能你懂的</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h4&gt;&lt;p&gt;使用 MacBook Pro 也2年多了，慢慢地积累了一些工作中好用的 APP，帮助自己更高效的工作。正版化也一直在进行着，除了 IDE 用的是教育版订阅之外，其他已经都是正版了（但我不排除 License 授权不支持工作用），力所能及的支持正版吧，毕竟自己也是软件开发从业者。&lt;/p&gt;
&lt;h4 id=&quot;APP-合集&quot;&gt;&lt;a href=&quot;#APP-合集&quot; class=&quot;headerlink&quot; title=&quot;APP 合集&quot;&gt;&lt;/a&gt;APP 合集&lt;/h4&gt;&lt;p&gt;每个 APP 对应一段简单的描述，数量还不多，就暂时不分类了，大概的排一下。&lt;br&gt;
    
    </summary>
    
      <category term="others" scheme="https://dearb.me/categories/others/"/>
    
    
  </entry>
  
  <entry>
    <title>前端工程化之前端架构及项目实践（二）</title>
    <link href="https://dearb.me/archive/2015-06-03/front-end-architecture-and-project-practice-part-2/"/>
    <id>https://dearb.me/archive/2015-06-03/front-end-architecture-and-project-practice-part-2/</id>
    <published>2015-06-03T08:42:40.000Z</published>
    <updated>2015-06-04T07:08:26.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="构建工具-FIS-的使用"><a href="#构建工具-FIS-的使用" class="headerlink" title="构建工具 - FIS 的使用"></a>构建工具 - FIS 的使用</h3><p>13年下半年的时候，第一次接触前端的构建工具，那时候好像刚好在某个会议上百度宣布了 FIS 这个工具，然后就选择了 FIS （其实小部分的原因是因为有中文文档，这个习惯非常不好，我现在已经强制改掉了）。由于那时候前置知识比较欠缺，使用起来还是有点吃力的，但是基本的功能也在项目开发中起到了很大的帮助。嗯，那时候还比较菜，啥都不知道。</p><p>后来来到了现在这个团队，根据公司内部已有的项目，改用了 Grunt 来作为项目的构建工具。那时候需求还比较简单，Grunt 并没有太多欠缺的地方。再后来，由我操刀对项目进行全面的重构，我再次选择了 FIS。</p><p>由于前置知识的积累以及对 Grunt 的使用，再次使用 FIS 并没有遇到太多的阻碍。我想，如果你已经掌握了 Grunt，可以尝试下使用 FIS 作为某个项目的构建工具，应该会很快的清楚两者之间的差距。</p><p>以下开始介绍 FIS 在我所跟的项目里的使用，并没有太基础的入门教程哦，官方的文档虽然写的烂七八糟的，但是还是可以看滴。实在不懂就可以搜索下 issue 或者加入官方基友群，900多号全国顶级互联网公司前端为你解答疑问！</p><a id="more"></a><h4 id="第三方组件的管理"><a href="#第三方组件的管理" class="headerlink" title="第三方组件的管理"></a>第三方组件的管理</h4><p>为了避免重复的制造轮子，一般项目中均会有一定数量的第三方组件，这些第三方的组件理应该不属于源码一样进行管理，而需要在一个地方用一个工具统一的管理它们，方便后期的维护。你可能比较熟悉的包管理工具是 Bower , FIS 内置的一个组件生态跟 Bower 其实是一样的理念。通过 <code>fis install</code> 等命令可以替代 Bower。之所以在选择中选择了 fis-components ，主要是因为：</p><ul><li>项目中使用了 mod.js ，需要遵循 commonJS ，fis-components 内置的转换工具可以转换任意的第三方组件</li><li>我们需要可以管理我们内部的私有组件</li></ul><h5 id="配置项目组件依赖"><a href="#配置项目组件依赖" class="headerlink" title="配置项目组件依赖"></a>配置项目组件依赖</h5><p>在我们的根目录下面建立 <code>component.json</code> 依赖声明文件</p><figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">"protocol"</span>: <span class="string">"github"</span>,</div><div class="line">  <span class="attr">"gihub"</span>: &#123;</div><div class="line">    <span class="attr">"author"</span>: <span class="string">"fis-components"</span></div><div class="line">  &#125;,</div><div class="line">  <span class="attr">"gitlab"</span>: &#123;</div><div class="line">    <span class="attr">"domain"</span>: <span class="string">"http://gitlab.rd.mt/"</span>,</div><div class="line">    <span class="attr">"author"</span>: <span class="string">"fee-components"</span></div><div class="line">  &#125;,</div><div class="line">  <span class="attr">"dependencies"</span>: [</div><div class="line">    <span class="string">"jquery@~1.9.1"</span>,</div><div class="line">    <span class="string">"vue@~0.11.10"</span>,</div><div class="line">    <span class="string">"gitlab:fee-components/jquery-drag@~0.0.1"</span></div><div class="line">  ]</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在项目目录下，通过 <code>fis install</code> 安装或者更新第三方组件</p><h5 id="转换一个第三方组件"><a href="#转换一个第三方组件" class="headerlink" title="转换一个第三方组件"></a>转换一个第三方组件</h5><p>将转换工具 <a href="https://github.com/fis-components/components" target="_blank" rel="external">fis-components/components</a> clone 回本地，在 <code>modules</code> 文件夹内新建一个组件的转换规则</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="meta">'use strict'</span>;</div><div class="line"></div><div class="line"><span class="built_in">module</span>.exports = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> [</div><div class="line">        &#123;</div><div class="line">            repos: <span class="string">'https://github.com/jquery/jquery.git'</span>,</div><div class="line">            version: <span class="string">'1.9.1'</span>,</div><div class="line">            name: <span class="string">'jquery'</span>,</div><div class="line">            main: <span class="string">'jquery.js'</span>,</div><div class="line">            build: <span class="string">'npm install &amp;&amp; npm install grunt-cli &amp;&amp; ./node_modules/.bin/grunt'</span>,</div><div class="line">            mapping: [</div><div class="line">                &#123;</div><div class="line">                    reg: <span class="regexp">/\.min\.(js|css)$/</span>,</div><div class="line">                    release: <span class="literal">false</span></div><div class="line">                &#125;,</div><div class="line">                &#123;</div><div class="line">                    reg: <span class="regexp">/^\/dist\/(.*\.js)/</span>,</div><div class="line">                    release: <span class="string">'$1'</span></div><div class="line">                &#125;,</div><div class="line">                &#123;</div><div class="line">                    reg: <span class="regexp">/^\/README\.md$/</span>,</div><div class="line">                    release: <span class="string">'$&amp;'</span></div><div class="line">                &#125;,</div><div class="line">                &#123;</div><div class="line">                    reg: <span class="string">'*'</span>,</div><div class="line">                    release: <span class="literal">false</span></div><div class="line">                &#125;</div><div class="line">            ]</div><div class="line">        &#125;,</div><div class="line"></div><div class="line">        &#123;</div><div class="line">            version: <span class="string">'2.1.0'</span>,</div><div class="line">            build: <span class="string">'npm run build'</span>,</div><div class="line">            extend: <span class="string">'1.9.1'</span></div><div class="line">        &#125;</div><div class="line"></div><div class="line">    ]</div><div class="line">&#125;)();</div></pre></td></tr></table></figure><p>本地拉取远程源仓库代码，并执行转换 <code>node test.js modules/jquery.js</code> 。转换出来的是符合 CommonJs 规范的组件，并去掉了多余的文件。</p><p>如果这是个公开的组件，将配置文件通过 Pull requests 提交回 FIS 组件生态；如果这是个私有组件，提交回内部的 gitlab。</p><h5 id="使用一个第三方组件"><a href="#使用一个第三方组件" class="headerlink" title="使用一个第三方组件"></a>使用一个第三方组件</h5><p>像写 node.js 一样写前端代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">require(&apos;bootstrap/button&apos;);</div><div class="line">var $ = require(&apos;jquery&apos;);</div><div class="line"></div><div class="line"></div><div class="line">$(&apos;.btn&apos;).click(function() &#123;</div><div class="line">    alert(&apos;Magic&apos;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure><h4 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h4><p>借助 FIS，我们可以使项目组件化更加的容易。通过 <code>isMod</code> 标记文件为组件化文件，被标记成组件化的 JS 文件会进行组件化包装。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    reg: <span class="regexp">/\/modules\/([^\/]+)\/\1\.js$/</span>,</div><div class="line">    id: <span class="string">'$1'</span>,</div><div class="line">    isMod: <span class="literal">true</span></div><div class="line">&#125;,</div><div class="line">&#123;</div><div class="line">    reg: <span class="regexp">/^\/modules\/(.*)\.(js)$/i</span>,</div><div class="line">    isMod: <span class="literal">true</span>,</div><div class="line">    id: <span class="string">'$1'</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这里通过设置更短的 ID 进行依赖声明，这样我们就可以更方便的对一个组件进行引用 <code>require(&#39;modules/login&#39;)</code> </p><p>同时，FIS 支持同名依赖自动引用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 这里 require 了 login 模块</span></div><div class="line"><span class="comment"> * 除了 module/login/login.js 的文件会被加载外 </span></div><div class="line"><span class="comment"> * 同级目录下的 module/login/login.css 也会被自动加载</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="built_in">require</span>(<span class="string">'modules/login'</span>);</div></pre></td></tr></table></figure><h4 id="常规的性能优化"><a href="#常规的性能优化" class="headerlink" title="常规的性能优化"></a>常规的性能优化</h4><p><code>压缩资源</code> 通过 -o 指令可以对项目的资源进行压缩，包括 JS、CSS、HTML 等。压缩 HTML 需要额外插件支持 <a href="https://github.com/BelinChung/fis-optimizer-html-minifier" target="_blank" rel="external">BelinChung/fis-optimizer-html-minifier</a></p><p><code>合并资源</code> 通过 -p 指令可以对项目的资源进行打包合并。这个在下面会独立说一下，现在没啥说的，可能后面需求不同，觉得有可以详细说的余地。</p><p><code>添加MD5戳</code> 通过 -m 指令可以对项目的文件添加MD5戳。很多人停留在文件后面添加时间戳 xxx.js?t=xxxx 的时代，并仍希望继续做。通过对文件添加MD5戳进行“非覆盖式发布”的好处是：</p><ul><li>部署安全。每次上线，先上线静态资源，它不会覆盖线上文件，然后再上线html页面，就能切换资源了</li><li>缓存策略非常简单。对静态资源进行强缓存，性能好，缓存策略也简单</li><li>防止HTTP缓存投毒。这个我没接触到，只能说了解了下，具体可以看 <a href="http://www.cnblogs.com/index-html/p/wifi_hijack_3.html" target="_blank" rel="external">这里</a></li></ul><p><code>添加资源域名</code> 通过 -D 命令可以对项目的文件添加域名。配置项 <code>fis.config.set(&#39;roadmap.domain&#39;,&#39;http://cdn.domain.com&#39;);</code>，可以配置单机、多机，进行全部署或随机部署。</p><h4 id="智能打包"><a href="#智能打包" class="headerlink" title="智能打包"></a>智能打包</h4><p>项目打包也是性能优化的一部分，独立开来讲，是因为每个项目的打包需求不一样，而且 FIS 提供了不同的打包方式来满足不同的需求。</p><p>目前我在项目中通过额外的打包插件 <a href="https://github.com/fex-team/fis-packager-depscombine" target="_blank" rel="external">fex-team/fis-packager-depscombine</a> 进行打包。在 pack 中命中的文件，其依赖也会自动命中，意思就是指定某个入口的 HTML 文件，这个 HTML 依赖的所有 JS、CSS 都会被命中，打成一个合并包。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">fis.config.set(<span class="string">'pack'</span>, &#123;</div><div class="line">    <span class="string">'pkg/web_app.css'</span>: <span class="string">'index.html'</span>,</div><div class="line">    <span class="string">'pkg/web_app.js'</span>: <span class="string">'index.html'</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>最后会在 <code>pkg/</code> 文件夹内产出一个 all-in-one 的 <code>web_app.css</code>、<code>web_app.js</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;构建工具-FIS-的使用&quot;&gt;&lt;a href=&quot;#构建工具-FIS-的使用&quot; class=&quot;headerlink&quot; title=&quot;构建工具 - FIS 的使用&quot;&gt;&lt;/a&gt;构建工具 - FIS 的使用&lt;/h3&gt;&lt;p&gt;13年下半年的时候，第一次接触前端的构建工具，那时候好像刚好在某个会议上百度宣布了 FIS 这个工具，然后就选择了 FIS （其实小部分的原因是因为有中文文档，这个习惯非常不好，我现在已经强制改掉了）。由于那时候前置知识比较欠缺，使用起来还是有点吃力的，但是基本的功能也在项目开发中起到了很大的帮助。嗯，那时候还比较菜，啥都不知道。&lt;/p&gt;
&lt;p&gt;后来来到了现在这个团队，根据公司内部已有的项目，改用了 Grunt 来作为项目的构建工具。那时候需求还比较简单，Grunt 并没有太多欠缺的地方。再后来，由我操刀对项目进行全面的重构，我再次选择了 FIS。&lt;/p&gt;
&lt;p&gt;由于前置知识的积累以及对 Grunt 的使用，再次使用 FIS 并没有遇到太多的阻碍。我想，如果你已经掌握了 Grunt，可以尝试下使用 FIS 作为某个项目的构建工具，应该会很快的清楚两者之间的差距。&lt;/p&gt;
&lt;p&gt;以下开始介绍 FIS 在我所跟的项目里的使用，并没有太基础的入门教程哦，官方的文档虽然写的烂七八糟的，但是还是可以看滴。实在不懂就可以搜索下 issue 或者加入官方基友群，900多号全国顶级互联网公司前端为你解答疑问！&lt;/p&gt;
    
    </summary>
    
      <category term="Front-end" scheme="https://dearb.me/categories/Front-end/"/>
    
    
  </entry>
  
  <entry>
    <title>前端工程化之前端架构及项目实践（一）</title>
    <link href="https://dearb.me/archive/2015-06-03/front-end-architecture-and-project-practice-part-1/"/>
    <id>https://dearb.me/archive/2015-06-03/front-end-architecture-and-project-practice-part-1/</id>
    <published>2015-06-03T06:23:10.000Z</published>
    <updated>2015-06-04T07:17:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>很久以前，就在备忘录上面写好了这篇文章的大纲，希望抽个空把这个阶段前端工程化的一些心得以文字的方式记录下来，但是万事开头难，拖了很久。而且有很多东西我更提倡用面对面的交流去阐释，所以动手写这篇文章还是因为要在公司内部做一个分享会，算是先组织下语言吧。</p><p>我以前写了一篇博文叫 <a href="https://dearb.me/archive/2015-01-23/design-and-development-a-web-im-system/">《Web-IM 系统的前端设计与实现》</a> 大概的说了下当时的一些前端架构的东西。第一，那篇文章写的比较少，大概说了下；第二，前端技术发展的很快，现在这个项目的前端经过重构，已经完全跟当时不一样了，所以，还是另写一篇博文来细说下自己对前端工程化的一些看法及在项目上的实践。</p><p>由于本人能力有限，这篇博文也是以我目前最高水平能写出的东西，难免会有一些差错或不理想的地方，仅供大家参考，如果有任何的建议，欢迎 Email 我，一起交流！</p><a id="more"></a><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">技术选型</div><div class="line"></div><div class="line">开发规范</div><div class="line">- 编码规范</div><div class="line">- 使用 jshint</div><div class="line"></div><div class="line">构建工具 - FIS 的使用</div><div class="line">- 第三方组件管理</div><div class="line">- 模块化</div><div class="line">- 常规的性能优化</div><div class="line">- 智能打包</div><div class="line"></div><div class="line">模块化 - 组件式开发</div><div class="line">- 目录规范</div><div class="line">- 组件仓库</div><div class="line">- 开发一个组件</div><div class="line">- 通过事件进一步解耦</div></pre></td></tr></table></figure><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>前端发展的非常快，如果你是一个热衷于追求技术的前端，你会发现越来越多的开源项目和选择，让你眼花缭乱，措手不及。不过每个前端团队都需要打造自己的前端开发体系，同时前端工程化代表着现在的前端开发不再是那种简单而无趣的远古生物，而是一个很性感的、让你情不自禁的想要去深入的美女（别想歪，我可是很纯洁的！！）。</p><p>前端工程化需要哪些技术元素？让我引用瓶神的一张图来说明。因为太过于理论化的博文可能会有些无趣，我会按照自己对前端工程化的理解，重新组织文字来描述这些技术元素的构成。<br><img src="https://camo.githubusercontent.com/4c1358dc162d8b8e9594c771e5ecdde258670784/687474703a2f2f68746d6c6a732e62302e7570616979756e2e636f6d2f75706c6f6164732f313339383339343738313135352d515132303134303432352d312e706e67" alt="image-1"></p><h3 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h3><p>技术选型没有包括在上面图片的技术元素中，不过目前我所在的团队一个好的技术选型对于前端工程化有非常大的影响。可能在大的团队中，不需要技术选型，因为已经有很完善的技术沉淀，各种轮子都自己有。</p><ul><li>构建工具：FIS</li><li>模块加载器：mod.js (FIS 自带)</li><li>MV* 框架：Vue.js</li><li>动态样式语言：Less</li><li>包管理：fis-components</li></ul><p>其中 <code>FIS</code> 和 <code>Vue.js</code> 作为一个开发工具和一个开发框架，我认为在整个技术选型中非常重要，因为它们决定了项目迅捷开发的能力、后期的可维护性以及工程化的程度。</p><p>技术选型中最大的误区为了选择而选择，而是要充分考虑到项目实际、团队协作、可维护性、社区活跃程度等。</p><p>构建工具，我从 Grunt 换成了 FIS 是因为 FIS 更适合大型项目；模块加载器，我从 RequireJS 换成了 mod.js 是因为既然使用了 FIS mod.js 会更容易融入到项目中；开发框架，我没有选择 AngularJS，是因为 Vue.js 轻便，入手快，这样后面的成员会很快的加入到现有的开发中。当然，AngularJS 的生态会比 Vue.js 的好。</p><h3 id="开发规范"><a href="#开发规范" class="headerlink" title="开发规范"></a>开发规范</h3><p>正如瓶神所说，规范可以极大的提升开发效率，一个优秀的规范能帮助开发者快速定位问题，提升效率。而且如果团队中多人参与开发的话，开发规范还能保证代码的可维护性和可读性。</p><h5 id="编码规范"><a href="#编码规范" class="headerlink" title="编码规范"></a>编码规范</h5><p>每个团队均可以根据自己的实际情况去制定适合自己团队的编码规范，通过 <code>Code Review</code> 来确保这个规范被真正实施在团队的日常开发中。唯一要确保的是，在项目伊始，这个编码规范便应该被确立下来，在后期的开发中可进行小范围的调整。</p><p>这里有一个我觉得比较好的 HTML、CSS <a href="http://codeguide.bootcss.com/" target="_blank" rel="external">编码规范</a></p><h5 id="使用-JSHint"><a href="#使用-JSHint" class="headerlink" title="使用 JSHint"></a>使用 JSHint</h5><p>当然，有时候仅仅通过 <code>Code Review</code> 很难避免出现老眼昏花，毕竟年纪越大，眼神就越不好。所以，我们可以通过技术手段去加强编码规范在团队的推行。</p><ul><li>通过给 IDE 配置 JSHint 纠正日常编码习惯</li><li>通过给版本控制仓库配置 JSHint 强制拒绝不规范代码的提交</li></ul><p>按照我的经验，只需要一至两个月，团队成员在不需要 JSHint 的提示下就已经养成了书写符合当前团队编码规范的代码。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;很久以前，就在备忘录上面写好了这篇文章的大纲，希望抽个空把这个阶段前端工程化的一些心得以文字的方式记录下来，但是万事开头难，拖了很久。而且有很多东西我更提倡用面对面的交流去阐释，所以动手写这篇文章还是因为要在公司内部做一个分享会，算是先组织下语言吧。&lt;/p&gt;
&lt;p&gt;我以前写了一篇博文叫 &lt;a href=&quot;https://dearb.me/archive/2015-01-23/design-and-development-a-web-im-system/&quot;&gt;《Web-IM 系统的前端设计与实现》&lt;/a&gt; 大概的说了下当时的一些前端架构的东西。第一，那篇文章写的比较少，大概说了下；第二，前端技术发展的很快，现在这个项目的前端经过重构，已经完全跟当时不一样了，所以，还是另写一篇博文来细说下自己对前端工程化的一些看法及在项目上的实践。&lt;/p&gt;
&lt;p&gt;由于本人能力有限，这篇博文也是以我目前最高水平能写出的东西，难免会有一些差错或不理想的地方，仅供大家参考，如果有任何的建议，欢迎 Email 我，一起交流！&lt;/p&gt;
    
    </summary>
    
      <category term="Front-end" scheme="https://dearb.me/categories/Front-end/"/>
    
    
  </entry>
  
  <entry>
    <title>从多说迁移博客评论至 Disqus</title>
    <link href="https://dearb.me/archive/2015-05-17/transfer-comments-from-duoshuo-to-disqus/"/>
    <id>https://dearb.me/archive/2015-05-17/transfer-comments-from-duoshuo-to-disqus/</id>
    <published>2015-05-17T12:50:19.000Z</published>
    <updated>2015-05-17T13:14:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>按理来说，应该是一个很简单的过程。从多说导出标准的备份文件，导入 Disqus，就完事了。但是我就整整的折腾了几天，评论是导入进去了，但是在博文页面始终没有把原来的评论显示出来。今天下午，甚至向 Disqus 官方发送了求救邮件。</p><p>就在刚才，才发现原来 Disqus 是根据文章的 URL 作为 Primary Key 的，而我新的博客系统的文章 URL 结尾比原来的少了个 <code>/</code>。擦，就是这一个字符，导致没有把原先的评论显示出来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Old: http://example.com/article</div><div class="line">New: http://example.com/article/</div></pre></td></tr></table></figure><h3 id="导入的具体过程"><a href="#导入的具体过程" class="headerlink" title="导入的具体过程"></a>导入的具体过程</h3><p>首先，在多说的后台将评论（包括文章）导出为一个 <code>export.json</code> 文件。这个文件格式是不被 Disqus 认的，所以我们得把它转换成 wordpress 导出的文件格式</p><a id="more"></a><p>轮子已经有人造了，我们就不再重复造轮子。使用这个轮子 <a href="https://github.com/JamesPan/duoshuo-migrator" target="_blank" rel="external">JamesPan/duoshuo-migrator</a> 对 <code>export.json</code> 进行转换</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">pip install lxml</div><div class="line">python duoshuo-migrator.py -i ~/Desktop/export.json  -o disqus.xml</div></pre></td></tr></table></figure><p>将文件转换为 <code>disqus.xml</code></p><p>最后把 <code>disqus.xml</code> 通过 Disqus 后台的 Discussions -&gt; Import 进行导入。官方写着24小时会处理完队列，实际上，如果评论少的话，马上评论就被成功导入进去了</p><p>反正，就得坑在  Disqus 是根据文章的 URL 作为 Primary Key ，这个是文章的唯一重点</p><h3 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h3><p>其实，这篇博客没有在表达多说比 Disqus 差。在国内的话，多说加载比 Disqus 快，默认的社交分享也比较符合中国的国情。但是，有一颗折腾的心，没事多折腾折腾，其实也是挺好的啦！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;按理来说，应该是一个很简单的过程。从多说导出标准的备份文件，导入 Disqus，就完事了。但是我就整整的折腾了几天，评论是导入进去了，但是在博文页面始终没有把原来的评论显示出来。今天下午，甚至向 Disqus 官方发送了求救邮件。&lt;/p&gt;
&lt;p&gt;就在刚才，才发现原来 Disqus 是根据文章的 URL 作为 Primary Key 的，而我新的博客系统的文章 URL 结尾比原来的少了个 &lt;code&gt;/&lt;/code&gt;。擦，就是这一个字符，导致没有把原先的评论显示出来&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;Old: http://example.com/article&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;New: http://example.com/article/&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;导入的具体过程&quot;&gt;&lt;a href=&quot;#导入的具体过程&quot; class=&quot;headerlink&quot; title=&quot;导入的具体过程&quot;&gt;&lt;/a&gt;导入的具体过程&lt;/h3&gt;&lt;p&gt;首先，在多说的后台将评论（包括文章）导出为一个 &lt;code&gt;export.json&lt;/code&gt; 文件。这个文件格式是不被 Disqus 认的，所以我们得把它转换成 wordpress 导出的文件格式&lt;/p&gt;
    
    </summary>
    
      <category term="Hexo" scheme="https://dearb.me/categories/Hexo/"/>
    
    
  </entry>
  
  <entry>
    <title>使用 Hexo 搭建自己的博客，抛弃 Octopress</title>
    <link href="https://dearb.me/archive/2015-05-10/use-hexo-build-your-own-blog/"/>
    <id>https://dearb.me/archive/2015-05-10/use-hexo-build-your-own-blog/</id>
    <published>2015-05-10T07:03:57.000Z</published>
    <updated>2015-05-10T07:42:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>很久以前，写了一篇博文 <a href="https://dearb.me/archive/2013-08-27/how-to-deploy-octopress/">How To Deploy Octopress</a> , 介绍了如何使用 Octopress 搭建一个高B格的博客系统。   </p><p>可能是因为不熟悉 Ruby 的原因，自己修改好的博客主题（没有备份）在前几天因为 rake 命令无法运行的情况下，不小心清空了。本来想着重新写一遍的，但是越写越不顺手，就开始寻找一款新的博客系统。   </p><p>后来找到了 Hexo ，作为一个前端，看到是基于 Node.js 写的，当然是无法抗拒的，所以果断的开始折腾 Hexo。 </p><p>文章最后面，可以下载到这个博客现在所使用的 Hexo 主题，如果你喜好的话。  </p><h3 id="如何搭建"><a href="#如何搭建" class="headerlink" title="如何搭建"></a>如何搭建</h3><p>不想再累赘当中细节，愿意折腾的 Hexo 和 Octopress 的人，应该看文档基本就搞定了。而且因为是基于 Node.js , 不像 Octopress 在 Windows 平台下面会遇到一些不知所以然的问题。Hexo 明显容易很多，编译速度也快非常多。  </p><p>因为 Hexo 的作者是台湾人，还提供了简体中文的文档，多贴心，看不懂英文不能再成为你不动脑筋的借口了。</p><a id="more"></a><h3 id="从-Octopress-迁移到-Hexo"><a href="#从-Octopress-迁移到-Hexo" class="headerlink" title="从 Octopress 迁移到 Hexo"></a>从 Octopress 迁移到 Hexo</h3><p>其实他们基本上实现的理念和机制是一样的，所以迁移的过程非常简单。</p><p>迁移文章</p><pre><code>把 Octopress source/_posts 文件夹内的所有文件转移到 Hexo 的 source/_posts 文件夹即可</code></pre><p>改变新文章的命名格式（这个看个人喜好）</p><pre><code>在 _config.yml 中修改 new_post_name 参数</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">new_post_name: :year-:month-:day-:title.md</div></pre></td></tr></table></figure><p>保证以前的外链可被访问（这个比较重要）</p><pre><code>这个是要确保被搜索引擎索引的或者别人转载的外链能被正常的访问，不然404多不好在 _config.yml 中修改 permalink 参数</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">permalink: archive/:year-:month-:day/:title/</div></pre></td></tr></table></figure><h3 id="关于博客主题"><a href="#关于博客主题" class="headerlink" title="关于博客主题"></a>关于博客主题</h3><p>其实我还是挺喜好我以前的博客主题的，看惯了。所以我找了一款类似的 Hexo 主题，花了点时间把它改造成跟我以前的博客主题一模一样。</p><p>因为改造前的主题比较先进，所以改造后，现在这个主题比我以前的主题更叼了。</p><p>这款主题是基于 <a href="https://github.com/LouisBarranqueiro/tranquilpeak-hexo-theme" target="_blank" rel="external">tranquilpeak</a> 改造的。</p><p>你可以在这里下载到现在这个博客改造后的 Hexo 主题 <a href="https://github.com/BelinChung/tranquilpeak-hexo-theme" target="_blank" rel="external">BelinChung/tranquilpeak</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;很久以前，写了一篇博文 &lt;a href=&quot;https://dearb.me/archive/2013-08-27/how-to-deploy-octopress/&quot;&gt;How To Deploy Octopress&lt;/a&gt; , 介绍了如何使用 Octopress 搭建一个高B格的博客系统。   &lt;/p&gt;
&lt;p&gt;可能是因为不熟悉 Ruby 的原因，自己修改好的博客主题（没有备份）在前几天因为 rake 命令无法运行的情况下，不小心清空了。本来想着重新写一遍的，但是越写越不顺手，就开始寻找一款新的博客系统。   &lt;/p&gt;
&lt;p&gt;后来找到了 Hexo ，作为一个前端，看到是基于 Node.js 写的，当然是无法抗拒的，所以果断的开始折腾 Hexo。 &lt;/p&gt;
&lt;p&gt;文章最后面，可以下载到这个博客现在所使用的 Hexo 主题，如果你喜好的话。  &lt;/p&gt;
&lt;h3 id=&quot;如何搭建&quot;&gt;&lt;a href=&quot;#如何搭建&quot; class=&quot;headerlink&quot; title=&quot;如何搭建&quot;&gt;&lt;/a&gt;如何搭建&lt;/h3&gt;&lt;p&gt;不想再累赘当中细节，愿意折腾的 Hexo 和 Octopress 的人，应该看文档基本就搞定了。而且因为是基于 Node.js , 不像 Octopress 在 Windows 平台下面会遇到一些不知所以然的问题。Hexo 明显容易很多，编译速度也快非常多。  &lt;/p&gt;
&lt;p&gt;因为 Hexo 的作者是台湾人，还提供了简体中文的文档，多贴心，看不懂英文不能再成为你不动脑筋的借口了。&lt;/p&gt;
    
    </summary>
    
      <category term="Hexo" scheme="https://dearb.me/categories/Hexo/"/>
    
    
  </entry>
  
  <entry>
    <title>使用 Git Hook 实现网站的自动部署</title>
    <link href="https://dearb.me/archive/2015-03-30/automate-deploy-your-websites-with-git-hook/"/>
    <id>https://dearb.me/archive/2015-03-30/automate-deploy-your-websites-with-git-hook/</id>
    <published>2015-03-30T03:31:53.000Z</published>
    <updated>2015-03-30T07:24:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>自动化能解放人类的双手，而且更重要的是，因为按照规定的流程来走，也减少了很多误操作的产生。不知道大家平时都是怎么样更新自己生产环境的代码的，FTP 覆盖旧文件、服务器定时任务去 build 最新的源码，还是有更高级的做法？   </p><p>目前我在使用 Git Hook 来部署自己的项目。Git Hook 是 Git 提供的一个钩子，能被特定的事件触发后调用。其实，更通俗的讲，当你设置了 Git Hook 后，只要你的远程仓库收到一次 push 之后，Git Hook 就能帮你执行一次 bash 脚本。</p><p>下面是我使用 Git Hook 进行简单的自动化部署，可能还有更高级的做法，大家自己去挖掘。</p><h3 id="在服务器初始化一个远程-Git-仓库"><a href="#在服务器初始化一个远程-Git-仓库" class="headerlink" title="在服务器初始化一个远程 Git 仓库"></a>在服务器初始化一个远程 Git 仓库</h3><p><code>git init</code> 和 <code>git --bare init</code> 初始化出来的仓库是完全不一样的，具体我 Google 了下，英文倒是理解了，但是要翻译出中文却不知道用什么形容词去称呼这2种仓库。</p><p>这里我们要通过 <code>git --bare init</code> 初始化一个远程仓库</p><a id="more"></a><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">cd</span> ~</div><div class="line">$ mkdir testRepo</div><div class="line">$ <span class="built_in">cd</span> testRepo</div><div class="line">$ git --bare init</div></pre></td></tr></table></figure><h3 id="在服务器初始化一个本地-Git-仓库"><a href="#在服务器初始化一个本地-Git-仓库" class="headerlink" title="在服务器初始化一个本地 Git 仓库"></a>在服务器初始化一个本地 Git 仓库</h3><p>这个仓库就是通过 <code>git init</code> 初始化出来最常见的本地仓库，它的作用是拉去远程仓库（其实就在它旁边）最新的源码，然后在这个仓库里进行编译，把代码编译到 www 目录（网站的根目录）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">cd</span> ~</div><div class="line">$ mkdir testDeploy</div><div class="line">$ <span class="built_in">cd</span> testDeploy</div><div class="line">$ git <span class="built_in">clone</span> ~/testRepo <span class="comment">#从远程仓库 clone 出源码</span></div><div class="line">``` </div><div class="line"></div><div class="line"><span class="comment">### 为远程仓库设置 Hook</span></div><div class="line"></div><div class="line">```bash</div><div class="line">$ <span class="built_in">cd</span> ~/testRepo/hooks</div><div class="line">$ vim post-receive</div></pre></td></tr></table></figure><p><code>post-receive</code> 里面的执行脚本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/sh</span></div><div class="line"><span class="built_in">unset</span> GIT_DIR</div><div class="line">DeployPath=/home/user/testDeploy</div><div class="line">WwwPath=/home/wwwroot/testDeploy</div><div class="line"></div><div class="line"><span class="built_in">cd</span> <span class="variable">$DeployPath</span></div><div class="line">git add . -A &amp;&amp; git stash</div><div class="line">git pull origin master</div><div class="line"></div><div class="line"><span class="comment"># 下面这2步都是按照实际你自己添加的bash脚本</span></div><div class="line">fis release -Dompd <span class="variable">$WwwPath</span> <span class="comment"># 我使用的FIS，对前端代码进行编译</span></div><div class="line">qrsync /home/user/qiniutools/config.json <span class="comment"># 使用七牛同步工具进行同步</span></div></pre></td></tr></table></figure><p>最后，为 <code>post-receive</code> 添加可执行权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">chmod +x post-receive</div></pre></td></tr></table></figure><h3 id="为本地仓库添加-remote-源"><a href="#为本地仓库添加-remote-源" class="headerlink" title="为本地仓库添加 remote 源"></a>为本地仓库添加 remote 源</h3><p>这次的本地仓库就真的是你开发机上面的本地了。在你原有 Git 项目里面添加一条新的 remote 源，以后往这个 remote 源里面 push 代码就会自动触发上面那 bash 脚本了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git remote add deploy user@server.ip:/home/user/testRepo</div><div class="line">$ git push deploy master</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;自动化能解放人类的双手，而且更重要的是，因为按照规定的流程来走，也减少了很多误操作的产生。不知道大家平时都是怎么样更新自己生产环境的代码的，FTP 覆盖旧文件、服务器定时任务去 build 最新的源码，还是有更高级的做法？   &lt;/p&gt;
&lt;p&gt;目前我在使用 Git Hook 来部署自己的项目。Git Hook 是 Git 提供的一个钩子，能被特定的事件触发后调用。其实，更通俗的讲，当你设置了 Git Hook 后，只要你的远程仓库收到一次 push 之后，Git Hook 就能帮你执行一次 bash 脚本。&lt;/p&gt;
&lt;p&gt;下面是我使用 Git Hook 进行简单的自动化部署，可能还有更高级的做法，大家自己去挖掘。&lt;/p&gt;
&lt;h3 id=&quot;在服务器初始化一个远程-Git-仓库&quot;&gt;&lt;a href=&quot;#在服务器初始化一个远程-Git-仓库&quot; class=&quot;headerlink&quot; title=&quot;在服务器初始化一个远程 Git 仓库&quot;&gt;&lt;/a&gt;在服务器初始化一个远程 Git 仓库&lt;/h3&gt;&lt;p&gt;&lt;code&gt;git init&lt;/code&gt; 和 &lt;code&gt;git --bare init&lt;/code&gt; 初始化出来的仓库是完全不一样的，具体我 Google 了下，英文倒是理解了，但是要翻译出中文却不知道用什么形容词去称呼这2种仓库。&lt;/p&gt;
&lt;p&gt;这里我们要通过 &lt;code&gt;git --bare init&lt;/code&gt; 初始化一个远程仓库&lt;/p&gt;
    
    </summary>
    
      <category term="Git" scheme="https://dearb.me/categories/Git/"/>
    
    
  </entry>
  
  <entry>
    <title>通过开启 Nginx TLS SNI 来支持同一 IP 下多 SSL 证书</title>
    <link href="https://dearb.me/archive/2015-03-28/enable-tls-sni-to-support-multiple-certificates-on-the-same-ip/"/>
    <id>https://dearb.me/archive/2015-03-28/enable-tls-sni-to-support-multiple-certificates-on-the-same-ip/</id>
    <published>2015-03-28T14:31:55.000Z</published>
    <updated>2015-03-30T07:01:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>前几天说给博客部署 SSL 证书来提高逼格，后来因为自己一个项目的需要，也跟着申请了多了一张 SSL 证书，按照相同的流程部署上去后，发现前面的域名的证书都 load 到了新增加的那张证书。接着 Google 了下，原来是 Nginx 编译的时候没有开启 TLS SNI ，这样就导致了同一 IP 下只能支持一张证书。</p><h3 id="查看已安装的-Nginx-是否开启-TLS-SNI"><a href="#查看已安装的-Nginx-是否开启-TLS-SNI" class="headerlink" title="查看已安装的 Nginx 是否开启 TLS SNI"></a>查看已安装的 Nginx 是否开启 TLS SNI</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ nginx -V</div><div class="line">ginx version: nginx/1.6.2</div><div class="line">built by gcc 4.1.2 20080704 (Red Hat 4.1.2-55)</div><div class="line">TLS SNI support disabled</div><div class="line">configure arguments: --user=www --group=www --prefix=/usr/<span class="built_in">local</span>/nginx --with-http_stub_status_module --with-http_ssl_module --with-http_gzip_static_module</div></pre></td></tr></table></figure><p><code>TLS SNI support disabled</code> 即未开启</p><a id="more"></a><h3 id="下载支持-SNI-的-OpenSSL"><a href="#下载支持-SNI-的-OpenSSL" class="headerlink" title="下载支持 SNI 的 OpenSSL"></a>下载支持 SNI 的 OpenSSL</h3><p>重新编译 Nginx 需要 OpenSSL，下载并解压到某个目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">cd</span> ~</div><div class="line">$ wget http://www.openssl.org/<span class="built_in">source</span>/openssl-1.0.2a.tar.gz  </div><div class="line">$ tar zxvf openssl-1.0.2a.tar.gz</div></pre></td></tr></table></figure><h3 id="重新编译-Nginx"><a href="#重新编译-Nginx" class="headerlink" title="重新编译 Nginx"></a>重新编译 Nginx</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">cd</span> nginx-1.6.2 <span class="comment">#这里假设你已经下载比解压了nginx的源码</span></div><div class="line">$ ./configure --user=www --group=www \</div><div class="line">           --prefix=/usr/<span class="built_in">local</span>/nginx \</div><div class="line">           --with-http_stub_status_module \</div><div class="line">           --with-http_ssl_module \</div><div class="line">           --with-http_gzip_static_module \</div><div class="line">           --with-openssl=path/to/openssl-1.0.2a</div><div class="line">$ make</div><div class="line">$ mv /usr/<span class="built_in">local</span>/nginx/sbin/nginx /usr/<span class="built_in">local</span>/nginx/sbin/nginx.old <span class="comment">#备份旧的nginx</span></div><div class="line">$ cp objs/nginx /usr/<span class="built_in">local</span>/nginx/sbin/nginx <span class="comment">#替换编译好的nginx</span></div></pre></td></tr></table></figure><p>make 的编译选项加上 <code>--with-openssl=path/to/openssl-1.0.2a</code> 参数指向的是你解压的 OpenSSL 目录，make 编译完成后不要执行 make install ，直接将 objs 目录下编译好的新 nginx 执行文件 copy 到原来的路径下替换即可。</p><h3 id="确认已经开启-TLS-SNI"><a href="#确认已经开启-TLS-SNI" class="headerlink" title="确认已经开启 TLS SNI"></a>确认已经开启 TLS SNI</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ nginx -V</div><div class="line">ginx version: nginx/1.6.2</div><div class="line">built by gcc 4.1.2 20080704 (Red Hat 4.1.2-55)</div><div class="line">TLS SNI support enabled</div><div class="line">configure arguments: --user=www --group=www --prefix=/usr/<span class="built_in">local</span>/nginx --with-http_stub_status_module --with-http_ssl_modul --with-openssl=../../openssl-1.0.2a</div></pre></td></tr></table></figure><p>虽然是很简单的一件事，其实我折腾了好久，我一直以为是我 conf 文件哪里写错了，后来误打误撞发现原来是跟没有开启某些相关，希望能帮助大家少走不必要的路。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前几天说给博客部署 SSL 证书来提高逼格，后来因为自己一个项目的需要，也跟着申请了多了一张 SSL 证书，按照相同的流程部署上去后，发现前面的域名的证书都 load 到了新增加的那张证书。接着 Google 了下，原来是 Nginx 编译的时候没有开启 TLS SNI ，这样就导致了同一 IP 下只能支持一张证书。&lt;/p&gt;
&lt;h3 id=&quot;查看已安装的-Nginx-是否开启-TLS-SNI&quot;&gt;&lt;a href=&quot;#查看已安装的-Nginx-是否开启-TLS-SNI&quot; class=&quot;headerlink&quot; title=&quot;查看已安装的 Nginx 是否开启 TLS SNI&quot;&gt;&lt;/a&gt;查看已安装的 Nginx 是否开启 TLS SNI&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;$ nginx -V&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;ginx version: nginx/1.6.2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;built by gcc 4.1.2 20080704 (Red Hat 4.1.2-55)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;TLS SNI support disabled&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;configure arguments: --user=www --group=www --prefix=/usr/&lt;span class=&quot;built_in&quot;&gt;local&lt;/span&gt;/nginx --with-http_stub_status_module --with-http_ssl_module --with-http_gzip_static_module&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;TLS SNI support disabled&lt;/code&gt; 即未开启&lt;/p&gt;
    
    </summary>
    
      <category term="SSL" scheme="https://dearb.me/categories/SSL/"/>
    
    
  </entry>
  
  <entry>
    <title>使用 SSL 证书保护网站的访问</title>
    <link href="https://dearb.me/archive/2015-03-23/use-ssl-certificates-to-protect-your-website-visitors-data/"/>
    <id>https://dearb.me/archive/2015-03-23/use-ssl-certificates-to-protect-your-website-visitors-data/</id>
    <published>2015-03-23T14:52:10.000Z</published>
    <updated>2017-12-29T08:27:20.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>[update] 本文于 2017-12-29 进行过一次修订</code></p><p>我以前没有接触过 SSL ，导致签发人生中第一张 SSL 证书的时候，Private Key 是通过第三方生成的，理论上来说这张证书基本上是废了，因为你家门的钥匙都是别人帮你配的，谁知道他有没有留一个副本！所以 Private Key 一定得自己生成。   </p><p>以下的内容，随随便便搜索引擎便能搜索到更加详细的，我在这里也就不累赘了，大概的说一下一些简单的东西。</p><h3 id="SSL-证书有什么用"><a href="#SSL-证书有什么用" class="headerlink" title="SSL 证书有什么用"></a>SSL 证书有什么用</h3><ul><li>SSL 是一个加密协议，它能保证你的数据在传输的过程中不被截取   </li><li>它能保证你的网站的内容不被篡改，比如国内的各宽带运营商，强制在你的网站上加 Javascript 代码，投放广告   </li><li>iOS APP 和 小程序 强制要求使用 HTTPS 传输内容 </li></ul><a id="more"></a><h3 id="SSL-证书价格怎么样"><a href="#SSL-证书价格怎么样" class="headerlink" title="SSL 证书价格怎么样"></a>SSL 证书价格怎么样</h3><p>Let’s Encrypt 已提供免费 SSL 证书签发服务，感谢这个组织推动了整个互联网 HTTPS 化。目前，签发证书的成本其实还是蛮低的。如果你是个人使用，不防试试以下的 CA 签发的证书，如果你是商用，我觉得你应该比我更清楚应该去哪里签。</p><ul><li><a href="https://letsencrypt.org/" target="_blank" rel="external">Let’s Encrypt</a> 免费签单域名/多域名证书，有效期较短，3个月。</li><li><a href="https://freessl.org" target="_blank" rel="external">FreeSSL</a> 一个免费提供证书申请服务的第三方网站   </li><li>Comodo PositiveSSL 我在 namecheap.com 签的单域名证书，50多RMB。</li><li>各大云服务运营商都提供了免费的 SSL 签发服务</li></ul><h3 id="SSL-证书如何申请"><a href="#SSL-证书如何申请" class="headerlink" title="SSL 证书如何申请"></a>SSL 证书如何申请</h3><p>在哪家 CA 申请证书都是差不多的流程。你需要准备的是你申请域名的 Private Key 和通过 Private Key 生成的 CSR (CERTIFICATE REQUEST)，然后将 CSR 给 CA ，CA 域名审核通过后，将会给你一个 CRT SSL 证书。CSR 起到中间传递的作用，最后部署的时候，真正有用的只有  Private Key 和 CRT  </p><p>如果你觉得通过命令行生成 Private Key 和 CSR 麻烦的话，我这里推荐一个在线生成的网站，这个网站纯前端生成，无后端服务器，理论上是安全的。</p><p><a href="https://ym.github.io/jscsrgen/" target="_blank" rel="external">CSR Generator</a> </p><p>[！！重点！！] 记得生成之后，要点击下载 ZIP 包，里面含有 Private Key ，把它丢了就没救了。</p><h3 id="SSL-证书如何部署"><a href="#SSL-证书如何部署" class="headerlink" title="SSL 证书如何部署"></a>SSL 证书如何部署</h3><p>我觉得部署倒是挺简单的，把 私钥 和 域名证书 放在服务器上，配置 Nginx Conf ，reload 完事。</p><p>host.conf 相关配置</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">server</div><div class="line">&#123;</div><div class="line">    <span class="attribute">listen</span> <span class="number">443</span>;</div><div class="line">    </div><div class="line">    <span class="comment"># 其他内容 </span></div><div class="line"></div><div class="line">    <span class="attribute">ssl</span> <span class="literal">on</span>;</div><div class="line">    <span class="attribute">ssl_certificate</span> /etc/ssl/private/ssl.crt;</div><div class="line">    <span class="attribute">ssl_certificate_key</span> /etc/ssl/private/ssl.key;</div><div class="line">    <span class="attribute">ssl_session_timeout</span> <span class="number">5m</span>;</div><div class="line">    <span class="attribute">ssl_protocols</span> TLSv1 TLSv1.<span class="number">1</span> TLSv1.<span class="number">2</span>;</div><div class="line">    <span class="attribute">ssl_ciphers</span> AESGCM:ALL:!DH:!EXPORT:!RC4:+HIGH:!MEDIUM:!LOW:!aNULL:!eNULL;</div><div class="line">    <span class="attribute">ssl_prefer_server_ciphers</span> <span class="literal">on</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>把 HTTP 强制跳转至 HTTPS</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">server</div><div class="line">&#123;</div><div class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</div><div class="line">    <span class="attribute">server_name</span>  dearb.me;</div><div class="line">    <span class="attribute">rewrite</span>  <span class="regexp"> ^</span>  https://<span class="variable">$server_name</span><span class="variable">$request_uri</span>? <span class="literal">permanent</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="SSL证书的一些小问题"><a href="#SSL证书的一些小问题" class="headerlink" title="SSL证书的一些小问题"></a>SSL证书的一些小问题</h3><ul><li>Android 浏览器或某些 PC 浏览器上显示证书不受信任。你需要找到你所申请 CA 的证书及根证书等证书链，放在你的证书 <code>ssl.crt</code> 后面就OK了。<a href="https://certificatechain.io/" target="_blank" rel="external">证书链补全工具</a></li><li>浏览器上面没有显示绿标，而且灰色小黄标。那是因为你的页面含有 HTTP 协议的元素，全部使用 HTTPS ，就有小绿标了</li></ul><p>最后你可以在 <a href="https://www.ssllabs.com/ssltest/" target="_blank" rel="external">SSL Labs</a> 检测你的域名的 SSL 评分已经在各终端的信任情况。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;[update] 本文于 2017-12-29 进行过一次修订&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;我以前没有接触过 SSL ，导致签发人生中第一张 SSL 证书的时候，Private Key 是通过第三方生成的，理论上来说这张证书基本上是废了，因为你家门的钥匙都是别人帮你配的，谁知道他有没有留一个副本！所以 Private Key 一定得自己生成。   &lt;/p&gt;
&lt;p&gt;以下的内容，随随便便搜索引擎便能搜索到更加详细的，我在这里也就不累赘了，大概的说一下一些简单的东西。&lt;/p&gt;
&lt;h3 id=&quot;SSL-证书有什么用&quot;&gt;&lt;a href=&quot;#SSL-证书有什么用&quot; class=&quot;headerlink&quot; title=&quot;SSL 证书有什么用&quot;&gt;&lt;/a&gt;SSL 证书有什么用&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;SSL 是一个加密协议，它能保证你的数据在传输的过程中不被截取   &lt;/li&gt;
&lt;li&gt;它能保证你的网站的内容不被篡改，比如国内的各宽带运营商，强制在你的网站上加 Javascript 代码，投放广告   &lt;/li&gt;
&lt;li&gt;iOS APP 和 小程序 强制要求使用 HTTPS 传输内容 &lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="SSL" scheme="https://dearb.me/categories/SSL/"/>
    
    
  </entry>
  
  <entry>
    <title>Web-IM 系统的前端设计与实现</title>
    <link href="https://dearb.me/archive/2015-01-23/design-and-development-a-web-im-system/"/>
    <id>https://dearb.me/archive/2015-01-23/design-and-development-a-web-im-system/</id>
    <published>2015-01-23T11:28:09.000Z</published>
    <updated>2015-01-23T11:34:15.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>从14年3月份入职之后，就一直在跟公司的一个即时 IM 的 Web APP 。15年已经来了，博客还没有一篇更新，就来聊聊在做这个 APP 的时候遇到的一些坑和一些总结吧。由于刚开始经验有限，所以在系统设计方面有很多的缺陷和不足，随着知识的积累，通过不断调整项目目录和一些规范，最终变成了下面的前端模型。</p><h3 id="设计理念"><a href="#设计理念" class="headerlink" title="设计理念"></a>设计理念</h3><p>期间重构时受到 <a href="http://www.dropbox.com/s/4d82npjuvenvkwx/UC%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5.pdf?dl=0" target="_blank" rel="external">UC前端工程实践.pdf</a> <code>模块化开发</code> 开发思想的影响，我们也在 APP 中引入了 <code>模块化</code> 的概念。正如里面所说：我们希望能像搭积木一样开发和维护系统，最终通过组装模块得到一个完整的应用。</p><ul><li>模块是可组合、可分解和更换的单元</li><li>模块具有一定的独立性</li><li>将模块所需的js、css、图片、模板维护在一起 ( 我们未采用 )</li><li>组件生态，同团队不同项目之间能有可复用的模块</li></ul><a id="more"></a><h3 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h3><h4 id="前端构建工具：F-I-S"><a href="#前端构建工具：F-I-S" class="headerlink" title="前端构建工具：F.I.S"></a>前端构建工具：<a href="http://fis.baidu.com" target="_blank" rel="external">F.I.S</a></h4><p>我们在 FIS 和 Grunt 之间选择了后者 - 国产的 FIS  ，基于如下的考虑：Grunt 是一个基于 task 的构建工具，依赖众多的插件进行配置组织，可以解决基本的前端自动化问题。FIS 是基于工具、开发框架、本地开发环境为一体的前端解决方案，不但拥有各类工具插件，同时还针对 PC、Mobile、I18n 等业务、场景总结了很多最佳实践。简单来说就是 FIS 更适合大型工程化的项目。</p><h4 id="模块加载器：RequireJS"><a href="#模块加载器：RequireJS" class="headerlink" title="模块加载器：RequireJS"></a>模块加载器：<a href="http://requirejs.org" target="_blank" rel="external">RequireJS</a></h4><p>通过 <a href="http://github.com/fex-team/fis-postprocessor-amd" target="_blank" rel="external">fis-postprocessor-amd</a> 的支持，FIS 能很好的支持 amd ，完全满足 amdjs 规范。至于选择哪个模块加载器，似乎也不是特别重要。</p><h4 id="动态样式语言：Less"><a href="#动态样式语言：Less" class="headerlink" title="动态样式语言：Less"></a>动态样式语言：<a href="http://lesscss.org" target="_blank" rel="external">Less</a></h4><p>没啥好说的，你喜欢 less 就用 less ，喜欢 Sass ，就用 Sass 。</p><h4 id="MV-框架：Vue-js"><a href="#MV-框架：Vue-js" class="headerlink" title="MV* 框架：Vue.js"></a>MV* 框架：<a href="http://vuejs.org" target="_blank" rel="external">Vue.js</a></h4><p>我们觉得 MV* 框架的选择非常重要，这关系着项目开发进度和后期维护。前端的轮子很多，我们不是大厂，没有实力也没有必要自己去造一个。一开始的提议是选用 Angular ，但是考虑到 Angular 的入门门槛，后期维护难度会加大，我们最终选择了 Vue.js （未考虑 IE 8- 的兼容）。</p><p>主要原因大概是：Vue.js 更灵活，允许你按照自己的方式来架构你的程序，而不是所有事情都必须按照 Angular 的方式运行；Vue.js 比 Angular 简单的多，所以你可以在很快的时间内学到它所有的东西然后变得更有效率。<br>由于 Vue.js 关注点在 MVVM 模式的 ViewModel 层，所有还需要额外的第三方库进行支持。</p><p>vue-router:  <a href="http://github.com/flatiron/director" target="_blank" rel="external">flatiron/director</a><br>vue-resource: jQuery Ajax</p><h3 id="开发目录"><a href="#开发目录" class="headerlink" title="开发目录"></a>开发目录</h3><p>并不是所有的项目都适合下面的开发目录。不同的开发模式、协作、打包策略都会影响都会影响开发目录的结构，其实没必要纠结哪种开发目录更美观、更合理。还是根据实际的需求不断的调整，直至它更适合你们团队、项目。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">Project</div><div class="line">  |-- i18n</div><div class="line">      |-- index.js</div><div class="line">      |-- index-zh_CN.js</div><div class="line">  |-- script</div><div class="line">      |-- util</div><div class="line">      |-- module</div><div class="line">          |-- home</div><div class="line">              |-- index.js</div><div class="line">              |-- service.js</div><div class="line">      |-- main.js</div><div class="line">  |-- style</div><div class="line">      |-- common</div><div class="line">      |-- widget</div><div class="line">          |-- dialog</div><div class="line">              |-- index.less</div><div class="line">              |-- index-red.less</div><div class="line">      |-- module</div><div class="line">          |-- home</div><div class="line">              |-- index.less</div><div class="line">              |-- index-red.less</div><div class="line">      |-- index.less</div><div class="line">      |-- index-red.less</div><div class="line">  |-- template</div><div class="line">      |-- widget</div><div class="line">          |-- dialog.tpl.html</div><div class="line">      |-- module</div><div class="line">          |-- home.tpl.html</div><div class="line">      |-- index.tpl.html</div><div class="line">  |-- vendors</div><div class="line">  |-- jquery</div><div class="line">  |-- jquery.js</div><div class="line">  |-- index.html</div><div class="line">  |-- fis-conf.js</div></pre></td></tr></table></figure><p>子目录基本上是按照结构、样式和脚本来划分。细化到各个子目录，基本上是按照模块来划分,关于结构，也就是模板，可能很多时候一个模块的模板可以将其融合在一个文件中，所以就没有单独建立一个目录，如果一个模块的结构比较复杂，可以像脚本和样式那样来建立相应的模块目录。各个模块会有相关的主题外观。</p><h4 id="开发一个组件"><a href="#开发一个组件" class="headerlink" title="开发一个组件"></a>开发一个组件</h4><p>Vue.js 允许你把扩展的 Vue 子类当曾一个可重用的组件，概念上和 web 组件一样，但是不需要任何填充。为了创建一个组件，只需要使用 Vue.extend() 来创建一个子类的构造函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//script/main.js</span></div><div class="line"></div><div class="line"><span class="keyword">new</span> Vue(&#123;</div><div class="line">  el: <span class="string">'body'</span>,</div><div class="line">  data: &#123;</div><div class="line">    currentView: <span class="string">'home'</span></div><div class="line">  &#125;,</div><div class="line">  components: &#123;</div><div class="line">    login-component: <span class="built_in">require</span>(<span class="string">'login/index'</span>), </div><div class="line">    home-component: <span class="built_in">require</span>(<span class="string">'home/index'</span>),</div><div class="line">    archive-component: <span class="built_in">require</span>(<span class="string">'archive/index'</span>)</div><div class="line">  &#125;</div><div class="line">&#125;)</div><div class="line"><span class="string">``</span><span class="string">` </span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">`</span><span class="string">``</span> javascript</div><div class="line"><span class="comment">//script/moudle/login/index.js</span></div><div class="line"></div><div class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params">require,exports,module</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> Vue = <span class="built_in">require</span>(<span class="string">'Vue'</span>);</div><div class="line">    <span class="keyword">var</span> store = <span class="built_in">require</span>(<span class="string">'services/store'</span>);</div><div class="line">    <span class="keyword">var</span> service = <span class="built_in">require</span>(<span class="string">'login/service'</span>);</div><div class="line"></div><div class="line">    <span class="built_in">module</span>.exports = &#123;</div><div class="line">        replace: <span class="literal">true</span>,</div><div class="line">        template: __inline(<span class="string">'login.tpl.html'</span>),</div><div class="line">        data: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> &#123;</div><div class="line">                email: <span class="string">''</span>,</div><div class="line">                password: <span class="string">''</span>,</div><div class="line">                errorTip: <span class="literal">null</span></div><div class="line">            &#125;</div><div class="line">        &#125;,</div><div class="line">        filters: &#123;</div><div class="line">            emailValidator: &#123;</div><div class="line">                write: <span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</div><div class="line">                    <span class="keyword">this</span>.errorTip = (appFunc.isEmail(val)) ? <span class="literal">null</span> : <span class="string">'邮箱必须是Email'</span>;</div><div class="line">                    <span class="keyword">return</span> val</div><div class="line">                &#125;</div><div class="line">            &#125;,</div><div class="line">            pwdValidator: &#123;</div><div class="line">                write: <span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</div><div class="line">                    <span class="keyword">this</span>.errorTip = (appFunc.isPasswd(val)) ? <span class="literal">null</span> : <span class="string">'密码在6-18位之间'</span>;</div><div class="line">                    <span class="keyword">return</span> val</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;,</div><div class="line">        methods: &#123;</div><div class="line">            loginSubmit: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">                <span class="keyword">var</span> data = &#123;</div><div class="line">                    email : <span class="keyword">this</span>.email,</div><div class="line">                    password: <span class="keyword">this</span>.password</div><div class="line">                &#125;;</div><div class="line">                <span class="keyword">if</span>(!<span class="keyword">this</span>.errorTip &amp; data.email !== <span class="string">''</span> &amp;&amp; data.password !== <span class="string">''</span>) &#123;</div><div class="line">                    service.login(data, <span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;</div><div class="line">                        <span class="keyword">if</span>(res.result)&#123;</div><div class="line">                            store.setCurrentUser(res.message.sid, res.message.user);</div><div class="line">                            appRouter.setRoute(<span class="string">'index'</span>);</div><div class="line">                        &#125;</div><div class="line">                    &#125;);</div><div class="line"></div><div class="line">                &#125;<span class="keyword">else</span>&#123;</div><div class="line">                    <span class="keyword">this</span>.errorTip = <span class="string">'请输入正确的账号、密码'</span></div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">&#125;);</div></pre></td></tr></table></figure><h4 id="打包部署"><a href="#打包部署" class="headerlink" title="打包部署"></a>打包部署</h4><p>通过配置 FIS  的，我们能对产出的代码进行 <code>资源压缩</code>  <code>添加文件版本</code>  <code>资源合并</code>  <code>添加CDN域名</code>  <code>应用打包</code> , 其中 <code>应用打包</code> 比较蛋疼，我还在研究如何配置才能达到我最终想要的打包效果。</p><p>项目通过 <code>git hook</code> 进行部署和更新。通过生产服务器上的 FIS 对仓库源码进行编译，编译目标指向 APP 目录。</p><h4 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h4><p>虽然标题上写着 设计和实现 ，但是本文基本上还是介绍系统的设计为主。希望有时间能写下 Web-IM 的一些实现，主要是 IM 这块比较有意思。</p><p>因为前端的数据和界面都通过 WebSocket 主动通知来进行更新，为了减少模块间的耦合，我们还引入了一套基于事件的模块间的消息传递的组件。而且，因为 Vue.js 拥有数据双向绑定的能力，处理起频繁更新的 VM 层还是相当便捷的。</p><p>大概就写到这里了，想到了就写下来，不然过几天又忘了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h3&gt;&lt;p&gt;从14年3月份入职之后，就一直在跟公司的一个即时 IM 的 Web APP 。15年已经来了，博客还没有一篇更新，就来聊聊在做这个 APP 的时候遇到的一些坑和一些总结吧。由于刚开始经验有限，所以在系统设计方面有很多的缺陷和不足，随着知识的积累，通过不断调整项目目录和一些规范，最终变成了下面的前端模型。&lt;/p&gt;
&lt;h3 id=&quot;设计理念&quot;&gt;&lt;a href=&quot;#设计理念&quot; class=&quot;headerlink&quot; title=&quot;设计理念&quot;&gt;&lt;/a&gt;设计理念&lt;/h3&gt;&lt;p&gt;期间重构时受到 &lt;a href=&quot;http://www.dropbox.com/s/4d82npjuvenvkwx/UC%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5.pdf?dl=0&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;UC前端工程实践.pdf&lt;/a&gt; &lt;code&gt;模块化开发&lt;/code&gt; 开发思想的影响，我们也在 APP 中引入了 &lt;code&gt;模块化&lt;/code&gt; 的概念。正如里面所说：我们希望能像搭积木一样开发和维护系统，最终通过组装模块得到一个完整的应用。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;模块是可组合、可分解和更换的单元&lt;/li&gt;
&lt;li&gt;模块具有一定的独立性&lt;/li&gt;
&lt;li&gt;将模块所需的js、css、图片、模板维护在一起 ( 我们未采用 )&lt;/li&gt;
&lt;li&gt;组件生态，同团队不同项目之间能有可复用的模块&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>同时使用 GitHub 和 GitCafe 托管 octopress</title>
    <link href="https://dearb.me/archive/2014-07-28/use-github-and-gitcafe-hosting-octopress/"/>
    <id>https://dearb.me/archive/2014-07-28/use-github-and-gitcafe-hosting-octopress/</id>
    <published>2014-07-28T12:47:00.000Z</published>
    <updated>2020-12-07T03:30:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>以前这个博客是托管在 stdyun 的，后来不知道什么原因（貌似被美团云收购？), octopress 托管服务终止了，原有的网站被转移在外国的服务器上，而且访问速度越来越慢，这不得不让我考虑重新寻找一个免费的 octopress 托管服务。<br>几经斟酌，觉得选用 GitHub 和 GitCafe ，他们分别是国外的、国内的代码托管服务商，也都提供 Git Pages 服务，我们可以把 octopress 托管在他们那。</p><h2 id="GitHub-Pages"><a href="#GitHub-Pages" class="headerlink" title="GitHub Pages"></a>GitHub Pages</h2><p>具体的托管操作在互联网上面大把，这里就不在累赘，大概如下</p><ul><li>GitHub 上面创建一个与你用户名相同前缀的 Repository ，比如我的 BelinChung/belinchung.github.io </li><li><code>cd path/your/octopress/folder</code></li><li>初始化 <code>rake setup_github_pages</code> ，按提示输入你的 Repository URL</li><li>编译和发布 <code>rake generate</code> <code>rake deploy</code> </li></ul><a id="more"></a> <h2 id="GitCafe-Pages"><a href="#GitCafe-Pages" class="headerlink" title="GitCafe Pages"></a>GitCafe Pages</h2><p>因为两家的产品都差不多，所以操作也是不尽相同，小区别在第一步，不需要 github.io 后缀</p><ul><li>GitCafe 上面创建一个与你用户名相同前缀的 Repository ，比如我的 BelinChung/belinchung  </li></ul><p>GitCafe 还提供的中文文档，可以去看看 <a href="https://gitcafe.com/GitCafe/Help/wiki/Pages-%E7%9B%B8%E5%85%B3%E5%B8%AE%E5%8A%A9#wiki" target="_blank" rel="external">GitCafe Pages Wiki</a></p><h2 id="域名绑定"><a href="#域名绑定" class="headerlink" title="域名绑定"></a>域名绑定</h2><ul><li><p>GitHub 需要在你的 octopress 的 source 目录下创建一个 CNAME 的文件，里面输入你想要绑定的域名，然后将域名 CNAME 到 yourname.github.io 上</p></li><li><p>GitCafe 后台可视化操作，非常方便，然后将域名 A 记录到 <code>117.79.146.98</code>  </p></li></ul><h2 id="同时使用"><a href="#同时使用" class="headerlink" title="同时使用"></a>同时使用</h2><p>开头我们说了，两家分别是国外和国内的代码托管服务商，GitHub 对于国外的访问（我猜的）比较友好，GitCafe 对于国内的访问比较迅速（必须的呀），能不能同时使用两家的托管服务，如果访问者是国外的 IP，走 GitHub ；反之，如果是国内的 IP ，走 GitCafe ?</p><p>答案是肯定是，我们使用 DNSPod 线路解析来实现“负载均衡”。</p><p>如何你的域名在 DNSPod 上面有一段时间了，那么你的线路类型里面直接有 <code>国内</code> 、<code>国外</code> 两个选项，你直接将 Github CNAME 记录的线路类型选择为 <code>国外</code> , GitCafe A 记录的线路类型选择为 <code>国内</code> 即可！</p><p><img src="https://bstatic.lufeng.info/QQ20140728-1@2x.png" alt="images"></p><p>如果你的域名线路类型里没有 <code>国内</code> 、<code>国外</code> 选项，也不用伤心，我们可以这么做<br>我们将 Github CNAME 记录的线路类型选择为 <code>默认</code>，将 GitCafe A 记录的线路类型分别选择为 <code>电信</code> 、 <code>联通</code> 、 <code>教育网</code> </p><p><img src="https://bstatic.lufeng.info/QQ20140728-2@2x.png-w700" alt="images"></p><h2 id="同时部署"><a href="#同时部署" class="headerlink" title="同时部署"></a>同时部署</h2><p>应该两家的服务不属于镜像的关系，所以得分别更新部署，不过在你的 <code>Rakefile</code> 文件下添加这2行代码，即可按照平时一样只执行 <code>rake generate</code> <code>rake deploy</code> 即可</p><pre><code class="ruby">cd <span class="string">"<span class="subst">#{deploy_dir}</span>"</span> <span class="keyword">do</span>    system <span class="string">"git add -A"</span>    puts <span class="string">"\n## Commiting: Site updated at <span class="subst">#{Time.now.utc}</span>"</span>    message = <span class="string">"Site updated at <span class="subst">#{Time.now.utc}</span>"</span>    system <span class="string">"git commit -m \"<span class="subst">#{message}</span>\""</span>    puts <span class="string">"\n## Pushing generated <span class="subst">#{deploy_dir}</span> website"</span>    system <span class="string">"git push origin <span class="subst">#{deploy_branch}</span>"</span>    puts <span class="string">"\n## Github Pages deploy complete"</span>    /*  增加这<span class="number">2</span>行，记得换上你的 git url *<span class="regexp">/</span><span class="regexp">    system "git remote add gitcafe git@gitcafe.com:belinchung/belinchung</span>.git <span class="meta">&gt;&gt; </span>/dev/null <span class="number">2</span>&gt;&amp;<span class="number">1</span><span class="string">"</span><span class="string">    system "</span>git push -u gitcafe <span class="symbol">master:</span>gitcafe-pages<span class="string">"</span><span class="string">end</span></code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以前这个博客是托管在 stdyun 的，后来不知道什么原因（貌似被美团云收购？), octopress 托管服务终止了，原有的网站被转移在外国的服务器上，而且访问速度越来越慢，这不得不让我考虑重新寻找一个免费的 octopress 托管服务。&lt;br&gt;几经斟酌，觉得选用 GitHub 和 GitCafe ，他们分别是国外的、国内的代码托管服务商，也都提供 Git Pages 服务，我们可以把 octopress 托管在他们那。&lt;/p&gt;
&lt;h2 id=&quot;GitHub-Pages&quot;&gt;&lt;a href=&quot;#GitHub-Pages&quot; class=&quot;headerlink&quot; title=&quot;GitHub Pages&quot;&gt;&lt;/a&gt;GitHub Pages&lt;/h2&gt;&lt;p&gt;具体的托管操作在互联网上面大把，这里就不在累赘，大概如下&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;GitHub 上面创建一个与你用户名相同前缀的 Repository ，比如我的 BelinChung/belinchung.github.io &lt;/li&gt;
&lt;li&gt;&lt;code&gt;cd path/your/octopress/folder&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;初始化 &lt;code&gt;rake setup_github_pages&lt;/code&gt; ，按提示输入你的 Repository URL&lt;/li&gt;
&lt;li&gt;编译和发布 &lt;code&gt;rake generate&lt;/code&gt; &lt;code&gt;rake deploy&lt;/code&gt; &lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>REST API 中调用校验 Token 的生成与维护</title>
    <link href="https://dearb.me/archive/2014-05-24/create-and-manage-access-token-for-rest-api/"/>
    <id>https://dearb.me/archive/2014-05-24/create-and-manage-access-token-for-rest-api/</id>
    <published>2014-05-24T15:02:00.000Z</published>
    <updated>2014-05-24T15:45:21.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="RESTful"><a href="#RESTful" class="headerlink" title="RESTful"></a>RESTful</h2><p>WEB APP 的概念越来越火，单页应用视乎也成为趋势，看着以前在 HTML 夹杂着用来渲染 View  层的 PHP 代码，总感觉好不舒服。自己也越来越趋向于前端和后端的代码完全分离开来。</p><p>现在是移动互联网的时代，我们发现几乎所有的网站、产品都不可避免的遇到一个需求：多平台整合。一个基于 RESTful  的后端架构是放眼未来的做法。</p><h2 id="Access-Token"><a href="#Access-Token" class="headerlink" title="Access Token"></a>Access Token</h2><p>捣鼓了那么久的微博开放平台的 API ，看到 Access Token 自然再熟悉不过了。OAuth2.0 授权成功后返回的一个授权码，可后续校验 API 调用的有效性。</p><a id="more"></a><p>嗯？OAuth2.0 对于我的应用来说太庞大了，在我的 RESTful 框架中，如何生成和维护这个 Token 呢？</p><p>首先我们来看看这个 Token 的的特性：</p><ul><li>通过随机算法生成(Hash)，里面包含这个 Token 对应用户的基本信息 </li><li>有生命周期，(TODO)可获得剩余的生命周期</li><li>可延续生命周期</li><li>(TODO)可主动销毁</li></ul><p>做久了前端，后端一些服务越来越模糊了，导致一开始把问题想复杂了，想通过可逆算法去生成这个 Token ,然后思维越走越远，后来经过 @苏奕嘉 小伙伴的指点，才发现，原来也就几行代码的事。</p><p>配合PHP 的拓展模块 Memcache (这里有个坑爹的地方，PHP的 Memcache 扩展有2个，Memcached 和 Memcache,我用的是后者)基本实现了 Token 的生成与维护。</p><p>写前端的，PHP写的不好，莫怪哈。</p><script src="//gist.github.com/be764f271f8328b4414c.js"></script>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;RESTful&quot;&gt;&lt;a href=&quot;#RESTful&quot; class=&quot;headerlink&quot; title=&quot;RESTful&quot;&gt;&lt;/a&gt;RESTful&lt;/h2&gt;&lt;p&gt;WEB APP 的概念越来越火，单页应用视乎也成为趋势，看着以前在 HTML 夹杂着用来渲染 View  层的 PHP 代码，总感觉好不舒服。自己也越来越趋向于前端和后端的代码完全分离开来。&lt;/p&gt;
&lt;p&gt;现在是移动互联网的时代，我们发现几乎所有的网站、产品都不可避免的遇到一个需求：多平台整合。一个基于 RESTful  的后端架构是放眼未来的做法。&lt;/p&gt;
&lt;h2 id=&quot;Access-Token&quot;&gt;&lt;a href=&quot;#Access-Token&quot; class=&quot;headerlink&quot; title=&quot;Access Token&quot;&gt;&lt;/a&gt;Access Token&lt;/h2&gt;&lt;p&gt;捣鼓了那么久的微博开放平台的 API ，看到 Access Token 自然再熟悉不过了。OAuth2.0 授权成功后返回的一个授权码，可后续校验 API 调用的有效性。&lt;/p&gt;
    
    </summary>
    
      <category term="php" scheme="https://dearb.me/categories/php/"/>
    
    
  </entry>
  
  <entry>
    <title>使用Framework7 创建有着iOS7原生体验的Web应用</title>
    <link href="https://dearb.me/archive/2014-05-04/develop-web-app-with-framework7/"/>
    <id>https://dearb.me/archive/2014-05-04/develop-web-app-with-framework7/</id>
    <published>2014-05-04T13:05:00.000Z</published>
    <updated>2020-12-07T03:30:40.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>好久没写博文了，最近生活比较动荡，同时忙着学业、工作、生活的事。为了能让自己在广州顽强的活下去，算是拼尽全力了。最近各方面也都开始逐渐稳定下来，就回来打理下博客，锄锄草，免得访问被杂草拌着了。</p><p>每次环境的更换都是对自己能力有着显著的提升，有时候你觉得在一个地方学不到或者基本重复着相同工作的时候，可以尝试换一个环境，可能对你未来的发展有更大的帮助。</p><p>当然，说这些是因为自己最近换了个工作，在新的公司跟了一个项目，很多以前不敢实践的东西由于进度和要求的压力都慢慢开始用上了，很高兴的有几个非常友好和屌丝的同事在身边指导我，帮助我，让项目一期的如期的完成，虽然还有很多坑，但是自己挖的，自己填就好了，O(∩_∩)O！</p><a id="more"></a><h2 id="WEB-APP-实践"><a href="#WEB-APP-实践" class="headerlink" title="WEB APP 实践"></a>WEB APP 实践</h2><p>很早以前便想着手做一个WEB APP练手，但是苦于技术能力，一直没有很完美的框架选择的技术选型，迟迟没有动手。刚进现在这个公司，刚好前端团队在跟一个移动模板，有现成的技术选型（主要还是身边有能问的人），在5.1几天假期里，给自己的项目(<a href="http://www.hiliaox.com" target="_blank" rel="external">Hi聊</a>)写了一个WEB APP前端模板，目前只是一个demo，未对接API。</p><h3 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h3><p><a href="http://m.hiliaox.com" target="_blank" rel="external">http://m.hiliaox.com</a></p><p><img src="https://bstatic.lufeng.info/chart_m_hiliao.png" alt="default"></p><h3 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h3><ul><li>HTML Framework: Framework7</li><li>Task Runner: Grunt</li><li>Module Loader: Require.js</li><li>Templates Engine: mustache </li></ul><h3 id="前端架构"><a href="#前端架构" class="headerlink" title="前端架构"></a>前端架构</h3><p>大家现在看到的demo 因为通过Grunt编译后的，里面只有一个js、css文件，算是没有开源吧，由于Hi聊是本人半商业化的产品，这个web app暂时不能“开源”出去，不过贴张代码的文件目录图。没有用第三方的MVC框架，自己按照自己的思路实现了简单的MVC。</p><p><img src="https://bstatic.lufeng.info/hiliaoapp_1.png-w700" alt="default"></p><h3 id="存在问题"><a href="#存在问题" class="headerlink" title="存在问题"></a>存在问题</h3><p>现在绝大部分的问题还是在Framework7 上，因为这个开源项目还刚刚开始（文档才2页），很多问题还没得修复或得到很好的解决，因为项目更新频繁（几天一次），自己现在马上去定制对后期的维护不利，所以我暂时放着。</p><ul><li>Framework7 文档不全，需要自己去阅读源码查看暴露的接口（我差不多看完一遍了）。</li><li>Framework7 在iOS 7浏览器上面表现完美，在低端Android 机上面基本没法玩。</li><li>在各平台各浏览器上面表现不一、Bug 多，有待完善。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;好久没写博文了，最近生活比较动荡，同时忙着学业、工作、生活的事。为了能让自己在广州顽强的活下去，算是拼尽全力了。最近各方面也都开始逐渐稳定下来，就回来打理下博客，锄锄草，免得访问被杂草拌着了。&lt;/p&gt;
&lt;p&gt;每次环境的更换都是对自己能力有着显著的提升，有时候你觉得在一个地方学不到或者基本重复着相同工作的时候，可以尝试换一个环境，可能对你未来的发展有更大的帮助。&lt;/p&gt;
&lt;p&gt;当然，说这些是因为自己最近换了个工作，在新的公司跟了一个项目，很多以前不敢实践的东西由于进度和要求的压力都慢慢开始用上了，很高兴的有几个非常友好和屌丝的同事在身边指导我，帮助我，让项目一期的如期的完成，虽然还有很多坑，但是自己挖的，自己填就好了，O(∩_∩)O！&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
